import "./chunk-TCQZMY3T.js";

// node_modules/vest-utils/dist/es/vest-utils.development.js
function bindNot(fn) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return !fn.apply(void 0, args);
  };
}
function isNumeric(value) {
  var str = String(value);
  var num = Number(value);
  var result = !isNaN(parseFloat(str)) && !isNaN(Number(value)) && isFinite(num);
  return Boolean(result);
}
var isNotNumeric = bindNot(isNumeric);
function numberEquals(value, eq) {
  return isNumeric(value) && isNumeric(eq) && Number(value) === Number(eq);
}
var numberNotEquals = bindNot(numberEquals);
function lengthEquals(value, arg1) {
  return numberEquals(value.length, arg1);
}
var lengthNotEquals = bindNot(lengthEquals);
function greaterThan(value, gt) {
  return isNumeric(value) && isNumeric(gt) && Number(value) > Number(gt);
}
function longerThan(value, arg1) {
  return greaterThan(value.length, arg1);
}
function createCache(maxSize) {
  if (maxSize === void 0) {
    maxSize = 1;
  }
  var cacheStorage = [];
  var cache2 = function(deps, cacheAction) {
    var cacheHit = cache2.get(deps);
    if (cacheHit)
      return cacheHit[1];
    var result = cacheAction();
    cacheStorage.unshift([deps.concat(), result]);
    if (longerThan(cacheStorage, maxSize))
      cacheStorage.length = maxSize;
    return result;
  };
  cache2.invalidate = function(deps) {
    var index = findIndex(deps);
    if (index > -1)
      cacheStorage.splice(index, 1);
  };
  cache2.get = function(deps) {
    return cacheStorage[findIndex(deps)] || null;
  };
  return cache2;
  function findIndex(deps) {
    return cacheStorage.findIndex(function(_a) {
      var cachedDeps = _a[0];
      return lengthEquals(deps, cachedDeps.length) && deps.every(function(dep, i) {
        return dep === cachedDeps[i];
      });
    });
  }
}
function isNull(value) {
  return value === null;
}
var isNotNull = bindNot(isNull);
function isUndefined(value) {
  return value === void 0;
}
var isNotUndefined = bindNot(isUndefined);
function isNullish(value) {
  return isNull(value) || isUndefined(value);
}
var isNotNullish = bindNot(isNullish);
function asArray(possibleArg) {
  return [].concat(possibleArg);
}
function isFunction(value) {
  return typeof value === "function";
}
function optionalFunctionValue(value) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return isFunction(value) ? value.apply(void 0, args) : value;
}
function defaultTo(value, defaultValue) {
  var _a;
  return (_a = optionalFunctionValue(value)) !== null && _a !== void 0 ? _a : optionalFunctionValue(defaultValue);
}
function isArray(value) {
  return Boolean(Array.isArray(value));
}
var isNotArray = bindNot(isArray);
function last(values) {
  var valuesArray = asArray(values);
  return valuesArray[valuesArray.length - 1];
}
function transform(array, cb) {
  var res = [];
  for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
    var v = array_1[_i];
    if (isArray(v)) {
      res.push(transform(v, cb));
    } else {
      var output = cb(v);
      if (isNotNull(output)) {
        res.push(output);
      }
    }
  }
  return res;
}
function valueAtPath(array, path) {
  return getCurrent(array, path)[last(path)];
}
function setValueAtPath(array, path, value) {
  var current = getCurrent(array, path);
  current[last(path)] = value;
  return array;
}
function flatten(values) {
  return asArray(values).reduce(function(acc, value) {
    if (isArray(value)) {
      return acc.concat(flatten(value));
    }
    return asArray(acc).concat(value);
  }, []);
}
function getCurrent(array, path) {
  var current = array;
  for (var _i = 0, _a = path.slice(0, -1); _i < _a.length; _i++) {
    var p = _a[_i];
    current[p] = defaultTo(current[p], []);
    current = current[p];
  }
  return current;
}
var nestedArray = Object.freeze({
  __proto__: null,
  transform,
  valueAtPath,
  setValueAtPath,
  flatten,
  getCurrent
});
function callEach(arr) {
  return arr.forEach(function(fn) {
    return fn();
  });
}
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isPromise(value) {
  return value && isFunction(value.then);
}
var assign = Object.assign;
function invariant(condition2, message) {
  if (condition2) {
    return;
  }
  throw message instanceof String ? message.valueOf() : new Error(message ? optionalFunctionValue(message) : message);
}
function StringObject(value) {
  return new String(optionalFunctionValue(value));
}
function isStringValue(v) {
  return String(v) === v;
}
function either(a, b) {
  return !!a !== !!b;
}
function isBoolean(value) {
  return !!value === value;
}
function deferThrow(message) {
  setTimeout(function() {
    throw new Error(message);
  }, 0);
}
function createBus() {
  var listeners = {};
  return {
    emit: function(event, data) {
      listener(event).forEach(function(handler) {
        handler(data);
      });
    },
    on: function(event, handler) {
      listeners[event] = listener(event).concat(handler);
      return {
        off: function() {
          listeners[event] = listener(event).filter(function(h) {
            return h !== handler;
          });
        }
      };
    }
  };
  function listener(event) {
    return listeners[event] || [];
  }
}
var bus = Object.freeze({
  __proto__: null,
  createBus
});
var seq = genSeq();
function genSeq(namespace) {
  return function(n) {
    return function() {
      return "".concat(namespace ? namespace + "_" : "").concat(n++);
    };
  }(0);
}
function mapFirst(array, callback) {
  var broke = false;
  var breakoutValue = null;
  for (var i = 0; i < array.length; i++) {
    callback(array[i], breakout, i);
    if (broke) {
      return breakoutValue;
    }
  }
  function breakout(conditional, value) {
    if (conditional) {
      broke = true;
      breakoutValue = value;
    }
  }
}
function isEmpty(value) {
  if (!value) {
    return true;
  } else if (hasOwnProperty(value, "length")) {
    return lengthEquals(value, 0);
  } else if (typeof value === "object") {
    return lengthEquals(Object.keys(value), 0);
  }
  return false;
}
var isNotEmpty = bindNot(isEmpty);
function isPositive(value) {
  return greaterThan(value, 0);
}

// node_modules/context/dist/es/context.development.js
var USEX_DEFAULT_ERROR_MESSAGE = "Not inside of a running context.";
var EMPTY_CONTEXT = Symbol();
function createContext(defaultContextValue) {
  var contextValue = EMPTY_CONTEXT;
  return {
    run,
    use,
    useX
  };
  function use() {
    return isInsideContext() ? contextValue : defaultContextValue;
  }
  function useX(errorMessage) {
    invariant(isInsideContext(), defaultTo(errorMessage, USEX_DEFAULT_ERROR_MESSAGE));
    return contextValue;
  }
  function run(value, cb) {
    var parentContext = isInsideContext() ? use() : EMPTY_CONTEXT;
    contextValue = value;
    var res = cb();
    contextValue = parentContext;
    return res;
  }
  function isInsideContext() {
    return contextValue !== EMPTY_CONTEXT;
  }
}
function createCascade(init) {
  var ctx2 = createContext();
  return {
    bind,
    run,
    use: ctx2.use,
    useX: ctx2.useX
  };
  function run(value, fn) {
    var _a;
    var parentContext = ctx2.use();
    var out = assign({}, parentContext ? parentContext : {}, (_a = optionalFunctionValue(init, value, parentContext)) !== null && _a !== void 0 ? _a : value);
    return ctx2.run(Object.freeze(out), fn);
  }
  function bind(value, fn) {
    return function() {
      var runTimeArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        runTimeArgs[_i] = arguments[_i];
      }
      return run(value, function() {
        return fn.apply(void 0, runTimeArgs);
      });
    };
  }
}

// node_modules/n4s/dist/es/n4s.development.js
function endsWith(value, arg1) {
  return isStringValue(value) && isStringValue(arg1) && value.endsWith(arg1);
}
var doesNotEndWith = bindNot(endsWith);
function equals(value, arg1) {
  return value === arg1;
}
var notEquals = bindNot(equals);
function greaterThanOrEquals(value, gte) {
  return numberEquals(value, gte) || greaterThan(value, gte);
}
function inside(value, arg1) {
  if (isArray(arg1)) {
    return arg1.indexOf(value) !== -1;
  }
  if (isStringValue(arg1) && isStringValue(value)) {
    return arg1.indexOf(value) !== -1;
  }
  return false;
}
var notInside = bindNot(inside);
function lessThan(value, lt) {
  return isNumeric(value) && isNumeric(lt) && Number(value) < Number(lt);
}
function lessThanOrEquals(value, lte) {
  return numberEquals(value, lte) || lessThan(value, lte);
}
function isBetween(value, min, max) {
  return greaterThanOrEquals(value, min) && lessThanOrEquals(value, max);
}
var isNotBetween = bindNot(isBetween);
function isBlank(value) {
  return isNullish(value) || isStringValue(value) && !value.trim();
}
var isNotBlank = bindNot(isBlank);
var isNotBoolean = bindNot(isBoolean);
var isEven = function(value) {
  if (isNumeric(value)) {
    return value % 2 === 0;
  }
  return false;
};
function isKeyOf(key, obj) {
  return key in obj;
}
var isNotKeyOf = bindNot(isKeyOf);
function isNaN2(value) {
  return Number.isNaN(value);
}
var isNotNaN = bindNot(isNaN2);
function isNegative(value) {
  return lessThan(value, 0);
}
function isNumber(value) {
  return Boolean(typeof value === "number");
}
var isNotNumber = bindNot(isNumber);
var isOdd = function(value) {
  if (isNumeric(value)) {
    return value % 2 !== 0;
  }
  return false;
};
var isNotString = bindNot(isStringValue);
function isTruthy(value) {
  return !!value;
}
var isFalsy = bindNot(isTruthy);
function isValueOf(value, objectToCheck) {
  if (isNullish(objectToCheck)) {
    return false;
  }
  for (var key in objectToCheck) {
    if (objectToCheck[key] === value) {
      return true;
    }
  }
  return false;
}
var isNotValueOf = bindNot(isValueOf);
function longerThanOrEquals(value, arg1) {
  return greaterThanOrEquals(value.length, arg1);
}
function matches(value, regex) {
  if (regex instanceof RegExp) {
    return regex.test(value);
  } else if (isStringValue(regex)) {
    return new RegExp(regex).test(value);
  }
  return false;
}
var notMatches = bindNot(matches);
function condition(value, callback) {
  try {
    return callback(value);
  } catch (_a) {
    return false;
  }
}
function shorterThan(value, arg1) {
  return lessThan(value.length, arg1);
}
function shorterThanOrEquals(value, arg1) {
  return lessThanOrEquals(value.length, arg1);
}
function startsWith(value, arg1) {
  return isStringValue(value) && isStringValue(arg1) && value.startsWith(arg1);
}
var doesNotStartWith = bindNot(startsWith);
function rules() {
  return {
    condition,
    doesNotEndWith,
    doesNotStartWith,
    endsWith,
    equals,
    greaterThan,
    greaterThanOrEquals,
    gt: greaterThan,
    gte: greaterThanOrEquals,
    inside,
    isArray,
    isBetween,
    isBlank,
    isBoolean,
    isEmpty,
    isEven,
    isFalsy,
    isKeyOf,
    isNaN: isNaN2,
    isNegative,
    isNotArray,
    isNotBetween,
    isNotBlank,
    isNotBoolean,
    isNotEmpty,
    isNotKeyOf,
    isNotNaN,
    isNotNull,
    isNotNullish,
    isNotNumber,
    isNotNumeric,
    isNotString,
    isNotUndefined,
    isNotValueOf,
    isNull,
    isNullish,
    isNumber,
    isNumeric,
    isOdd,
    isPositive,
    isString: isStringValue,
    isTruthy,
    isUndefined,
    isValueOf,
    lengthEquals,
    lengthNotEquals,
    lessThan,
    lessThanOrEquals,
    longerThan,
    longerThanOrEquals,
    lt: lessThan,
    lte: lessThanOrEquals,
    matches,
    notEquals,
    notInside,
    notMatches,
    numberEquals,
    numberNotEquals,
    shorterThan,
    shorterThanOrEquals,
    startsWith
  };
}
var baseRules = rules();
function getRule(ruleName) {
  return baseRules[ruleName];
}
function eachEnforceRule(action) {
  for (var ruleName in baseRules) {
    var ruleFn = getRule(ruleName);
    if (isFunction(ruleFn)) {
      action(ruleName, ruleFn);
    }
  }
}
var ctx = createCascade(function(ctxRef, parentContext) {
  var base = {
    value: ctxRef.value,
    meta: ctxRef.meta || {}
  };
  if (!parentContext) {
    return assign(base, {
      parent: emptyParent
    });
  } else if (ctxRef.set) {
    return assign(base, {
      parent: function() {
        return stripContext(parentContext);
      }
    });
  }
  return parentContext;
});
function stripContext(ctx2) {
  if (!ctx2) {
    return null;
  }
  return {
    value: ctx2.value,
    meta: ctx2.meta,
    parent: ctx2.parent
  };
}
function emptyParent() {
  return null;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function isProxySupported() {
  try {
    return isFunction(Proxy);
  } catch (_a) {
    return false;
  }
}
function ruleReturn(pass, message) {
  var output = { pass };
  if (message) {
    output.message = message;
  }
  return output;
}
function passing() {
  return ruleReturn(true);
}
function defaultToPassing(callback) {
  return defaultTo(callback, passing());
}
function transformResult(result, ruleName, value) {
  var args = [];
  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }
  validateResult(result);
  if (isBoolean(result)) {
    return ruleReturn(result);
  }
  return ruleReturn(result.pass, optionalFunctionValue.apply(void 0, __spreadArray([result.message, ruleName, value], args, false)));
}
function validateResult(result) {
  invariant(isBoolean(result) || result && isBoolean(result.pass), "Incorrect return value for rule: " + JSON.stringify(result));
}
function enforceEager(value) {
  var target = {
    message
  };
  var customMessage = void 0;
  if (!isProxySupported()) {
    eachEnforceRule(function(ruleName, ruleFn) {
      target[ruleName] = genRuleCall(target, ruleFn, ruleName);
    });
    return target;
  }
  var proxy = new Proxy(target, {
    get: function(_, key) {
      var rule = getRule(key);
      if (rule) {
        return genRuleCall(proxy, rule, key);
      }
      return target[key];
    }
  });
  return proxy;
  function genRuleCall(target2, rule, ruleName) {
    return function ruleCall() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformedResult = ctx.run({ value }, function() {
        return transformResult.apply(void 0, __spreadArray([rule.apply(void 0, __spreadArray([value], args, false)), ruleName, value], args, false));
      });
      function enforceMessage() {
        if (!isNullish(customMessage))
          return StringObject(customMessage);
        if (isNullish(transformedResult.message)) {
          return "enforce/".concat(ruleName, " failed with ").concat(JSON.stringify(value));
        }
        return StringObject(transformedResult.message);
      }
      invariant(transformedResult.pass, enforceMessage());
      return target2;
    };
  }
  function message(input) {
    customMessage = input;
    return proxy;
  }
}
function genEnforceLazy(key) {
  var registeredRules = [];
  var lazyMessage;
  return addLazyRule(key);
  function addLazyRule(ruleName) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var rule = getRule(ruleName);
      registeredRules.push(function(value) {
        return transformResult.apply(void 0, __spreadArray([rule.apply(void 0, __spreadArray([value], args, false)), ruleName, value], args, false));
      });
      var proxy = {
        run: function(value) {
          return defaultToPassing(mapFirst(registeredRules, function(rule2, breakout) {
            var _a;
            var res = ctx.run({ value }, function() {
              return rule2(value);
            });
            breakout(!res.pass, ruleReturn(!!res.pass, (_a = optionalFunctionValue(lazyMessage, value, res.message)) !== null && _a !== void 0 ? _a : res.message));
          }));
        },
        test: function(value) {
          return proxy.run(value).pass;
        },
        message: function(message) {
          if (message) {
            lazyMessage = message;
          }
          return proxy;
        }
      };
      if (!isProxySupported()) {
        eachEnforceRule(function(ruleName2) {
          proxy[ruleName2] = addLazyRule(ruleName2);
        });
        return proxy;
      }
      proxy = new Proxy(proxy, {
        get: function(target, key2) {
          if (getRule(key2)) {
            return addLazyRule(key2);
          }
          return target[key2];
        }
      });
      return proxy;
    };
  }
}
function genEnforce() {
  var target = {
    context: function() {
      return ctx.useX();
    },
    extend: function(customRules) {
      assign(baseRules, customRules);
      handleNoProxy();
    }
  };
  handleNoProxy();
  return new Proxy(assign(enforceEager, target), {
    get: function(target2, key) {
      if (key in target2) {
        return target2[key];
      }
      if (!getRule(key)) {
        return;
      }
      return genEnforceLazy(key);
    }
  });
  function handleNoProxy() {
    if (!isProxySupported()) {
      eachEnforceRule(function(ruleName) {
        target[ruleName] = genEnforceLazy(ruleName);
      });
      return assign(enforceEager, target);
    }
  }
}
var enforce = genEnforce();

// node_modules/vast/dist/es/vast.development.js
function createState(onStateChange) {
  var state = {
    references: []
  };
  var registrations = [];
  return {
    registerStateKey,
    reset
  };
  function registerStateKey(initialState, onUpdate) {
    var key = registrations.length;
    registrations.push([initialState, onUpdate]);
    return initKey(key, initialState);
  }
  function reset() {
    var prev = current();
    state.references = [];
    registrations.forEach(function(_a, index) {
      var initialValue = _a[0];
      return initKey(index, initialValue, prev[index]);
    });
  }
  function initKey(key, initialState, prevState) {
    current().push();
    set(key, optionalFunctionValue(initialState, prevState));
    return function useStateKey() {
      return [
        current()[key],
        function(nextState) {
          return set(key, optionalFunctionValue(nextState, current()[key]));
        }
      ];
    };
  }
  function current() {
    return state.references;
  }
  function set(index, value) {
    var prevValue = state.references[index];
    state.references[index] = value;
    var _a = registrations[index], onUpdate = _a[1];
    if (isFunction(onUpdate)) {
      onUpdate(value, prevValue);
    }
    if (isFunction(onStateChange)) {
      onStateChange();
    }
  }
}

// node_modules/vest/dist/es/vest.development.js
var IsolateTypes;
(function(IsolateTypes2) {
  IsolateTypes2[IsolateTypes2["DEFAULT"] = 0] = "DEFAULT";
  IsolateTypes2[IsolateTypes2["SUITE"] = 1] = "SUITE";
  IsolateTypes2[IsolateTypes2["EACH"] = 2] = "EACH";
  IsolateTypes2[IsolateTypes2["SKIP_WHEN"] = 3] = "SKIP_WHEN";
  IsolateTypes2[IsolateTypes2["OMIT_WHEN"] = 4] = "OMIT_WHEN";
  IsolateTypes2[IsolateTypes2["GROUP"] = 5] = "GROUP";
})(IsolateTypes || (IsolateTypes = {}));
function createStateRef(state, _a) {
  var suiteId = _a.suiteId, suiteName = _a.suiteName;
  return {
    optionalFields: state.registerStateKey(function() {
      return {};
    }),
    suiteId: state.registerStateKey(suiteId),
    suiteName: state.registerStateKey(suiteName),
    testCallbacks: state.registerStateKey(function() {
      return {
        fieldCallbacks: {},
        doneCallbacks: []
      };
    }),
    testObjects: state.registerStateKey(function(prev) {
      return {
        prev: prev ? prev.current : [],
        current: []
      };
    })
  };
}
var Modes;
(function(Modes2) {
  Modes2[Modes2["ALL"] = 0] = "ALL";
  Modes2[Modes2["EAGER"] = 1] = "EAGER";
})(Modes || (Modes = {}));
function createIsolateCursor() {
  var cursor = {
    value: 0
  };
  return {
    current,
    next
  };
  function current() {
    return cursor.value;
  }
  function next() {
    cursor.value++;
  }
}
function generateIsolate(type, path) {
  if (path === void 0) {
    path = [];
  }
  return {
    cursor: createIsolateCursor(),
    keys: {
      current: {},
      prev: {}
    },
    path,
    type
  };
}
var context = createCascade(function(ctxRef, parentContext) {
  return parentContext ? null : assign({
    exclusion: {
      tests: {},
      groups: {}
    },
    inclusion: {},
    isolate: generateIsolate(IsolateTypes.DEFAULT),
    mode: [Modes.ALL]
  }, ctxRef);
});
function useIsolate() {
  return context.useX().isolate;
}
function useCurrentPath() {
  var isolate2 = useIsolate();
  return isolate2.path.concat(isolate2.cursor.current());
}
function useCursor() {
  return useIsolate().cursor;
}
function shouldUseErrorAsMessage(message, error) {
  return isUndefined(message) && isStringValue(error);
}
function useStateRef() {
  return context.useX().stateRef;
}
function useSuiteId() {
  return useStateRef().suiteId()[0];
}
function useSuiteName() {
  return useStateRef().suiteName()[0];
}
function useTestCallbacks() {
  return useStateRef().testCallbacks();
}
function useOptionalFields() {
  return useStateRef().optionalFields();
}
function useSetOptionalField(fieldName, setter) {
  var _a = useOptionalFields(), setOptionalFields = _a[1];
  setOptionalFields(function(prev) {
    var _a2;
    return assign(prev, (_a2 = {}, _a2[fieldName] = assign({}, prev[fieldName], setter(prev[fieldName])), _a2));
  });
}
function useOptionalField(fieldName) {
  var _a;
  var optionalFields = useOptionalFields()[0];
  return (_a = optionalFields[fieldName]) !== null && _a !== void 0 ? _a : {};
}
function useTestObjects() {
  return useStateRef().testObjects();
}
function useRefreshTestObjects() {
  useSetTests(function(tests) {
    return tests;
  });
}
function useSetTests(handler) {
  var _a = useTestObjects(), testObjects = _a[1];
  testObjects(function(_a2) {
    var current = _a2.current, prev = _a2.prev;
    return {
      prev,
      current: asArray(handler(current))
    };
  });
}
function useAllIncomplete() {
  return useTestsFlat().filter(function(test2) {
    return test2.isPending();
  });
}
var flatCache = createCache();
function useTestsFlat() {
  var current = useTestObjects()[0].current;
  return flatCache([current], function() {
    return nestedArray.flatten(current);
  });
}
function useEachTestObject(handler) {
  var testObjects = useTestsFlat();
  testObjects.forEach(handler);
}
var TestSeverity;
(function(TestSeverity2) {
  TestSeverity2["Error"] = "error";
  TestSeverity2["Warning"] = "warning";
})(TestSeverity || (TestSeverity = {}));
var VestTest = (
  /** @class */
  function() {
    function VestTest2(fieldName, testFn, _a) {
      var _b = _a === void 0 ? {} : _a, message = _b.message, groupName = _b.groupName, key = _b.key;
      this.key = null;
      this.id = seq();
      this.severity = TestSeverity.Error;
      this.status = STATUS_UNTESTED;
      this.fieldName = fieldName;
      this.testFn = testFn;
      if (groupName) {
        this.groupName = groupName;
      }
      if (message) {
        this.message = message;
      }
      if (key) {
        this.key = key;
      }
    }
    VestTest2.prototype.run = function() {
      var result;
      try {
        result = this.testFn();
      } catch (error) {
        if (shouldUseErrorAsMessage(this.message, error)) {
          this.message = error;
        }
        result = false;
      }
      if (result === false) {
        this.fail();
      }
      return result;
    };
    VestTest2.prototype.setStatus = function(status) {
      if (this.isFinalStatus() && status !== STATUS_OMITTED) {
        return;
      }
      this.status = status;
    };
    VestTest2.prototype.warns = function() {
      return this.severity === TestSeverity.Warning;
    };
    VestTest2.prototype.setPending = function() {
      this.setStatus(STATUS_PENDING);
    };
    VestTest2.prototype.fail = function() {
      this.setStatus(this.warns() ? STATUS_WARNING : STATUS_FAILED);
    };
    VestTest2.prototype.done = function() {
      if (this.isFinalStatus()) {
        return;
      }
      this.setStatus(STATUS_PASSING);
    };
    VestTest2.prototype.warn = function() {
      this.severity = TestSeverity.Warning;
    };
    VestTest2.prototype.isFinalStatus = function() {
      return this.hasFailures() || this.isCanceled() || this.isPassing();
    };
    VestTest2.prototype.skip = function(force) {
      if (this.isPending() && !force) {
        return;
      }
      this.setStatus(STATUS_SKIPPED);
    };
    VestTest2.prototype.cancel = function() {
      this.setStatus(STATUS_CANCELED);
      useRefreshTestObjects();
    };
    VestTest2.prototype.reset = function() {
      this.status = STATUS_UNTESTED;
      useRefreshTestObjects();
    };
    VestTest2.prototype.omit = function() {
      this.setStatus(STATUS_OMITTED);
    };
    VestTest2.prototype.valueOf = function() {
      return !this.isFailing();
    };
    VestTest2.prototype.isPending = function() {
      return this.statusEquals(STATUS_PENDING);
    };
    VestTest2.prototype.isOmitted = function() {
      return this.statusEquals(STATUS_OMITTED);
    };
    VestTest2.prototype.isUntested = function() {
      return this.statusEquals(STATUS_UNTESTED);
    };
    VestTest2.prototype.isFailing = function() {
      return this.statusEquals(STATUS_FAILED);
    };
    VestTest2.prototype.isCanceled = function() {
      return this.statusEquals(STATUS_CANCELED);
    };
    VestTest2.prototype.isSkipped = function() {
      return this.statusEquals(STATUS_SKIPPED);
    };
    VestTest2.prototype.isPassing = function() {
      return this.statusEquals(STATUS_PASSING);
    };
    VestTest2.prototype.isWarning = function() {
      return this.statusEquals(STATUS_WARNING);
    };
    VestTest2.prototype.hasFailures = function() {
      return this.isFailing() || this.isWarning();
    };
    VestTest2.prototype.isNonActionable = function() {
      return this.isSkipped() || this.isOmitted() || this.isCanceled();
    };
    VestTest2.prototype.isTested = function() {
      return this.hasFailures() || this.isPassing();
    };
    VestTest2.prototype.awaitsResolution = function() {
      return this.isSkipped() || this.isUntested() || this.isPending();
    };
    VestTest2.prototype.statusEquals = function(status) {
      return this.status === status;
    };
    return VestTest2;
  }()
);
var STATUS_UNTESTED = "UNTESTED";
var STATUS_SKIPPED = "SKIPPED";
var STATUS_FAILED = "FAILED";
var STATUS_WARNING = "WARNING";
var STATUS_PASSING = "PASSING";
var STATUS_PENDING = "PENDING";
var STATUS_CANCELED = "CANCELED";
var STATUS_OMITTED = "OMITTED";
function usePrevKeys() {
  var prev = useTestObjects()[0].prev;
  return asArray(nestedArray.getCurrent(prev, useCurrentPath())).reduce(function(prevKeys, testObject) {
    if (!(testObject instanceof VestTest)) {
      return prevKeys;
    }
    if (isNullish(testObject.key)) {
      return prevKeys;
    }
    prevKeys[testObject.key] = testObject;
    return prevKeys;
  }, {});
}
function usePrevTestByKey(key) {
  var prev = useIsolate().keys.prev;
  return prev[key];
}
function useRetainTestKey(key, testObject) {
  var current = useIsolate().keys.current;
  if (isNullish(current[key])) {
    current[key] = testObject;
  } else {
    deferThrow('Encountered the same test key "'.concat(key, `" twice. This may lead to tests overriding each other's results, or to tests being unexpectedly omitted.`));
  }
}
function isolate(_a, callback) {
  var _b = _a.type, type = _b === void 0 ? IsolateTypes.DEFAULT : _b;
  invariant(isFunction(callback));
  var isolate2 = generateIsolate(type, useCurrentPath());
  var output = context.run({ isolate: isolate2 }, function() {
    isolate2.keys.prev = usePrevKeys();
    useSetTests(function(tests) {
      return nestedArray.setValueAtPath(tests, isolate2.path, []);
    });
    var res = callback();
    return res;
  });
  useCursor().next();
  return output;
}
function shouldAllowReorder() {
  return useIsolate().type === IsolateTypes.EACH;
}
var Severity;
(function(Severity2) {
  Severity2["WARNINGS"] = "warnings";
  Severity2["ERRORS"] = "errors";
})(Severity || (Severity = {}));
var SeverityCount;
(function(SeverityCount2) {
  SeverityCount2["ERROR_COUNT"] = "errorCount";
  SeverityCount2["WARN_COUNT"] = "warnCount";
})(SeverityCount || (SeverityCount = {}));
function countKeyBySeverity(severity) {
  return severity === Severity.ERRORS ? SeverityCount.ERROR_COUNT : SeverityCount.WARN_COUNT;
}
function nonMatchingFieldName(testObject, fieldName) {
  return !!fieldName && !matchingFieldName(testObject, fieldName);
}
function matchingFieldName(testObject, fieldName) {
  return !!(fieldName && testObject.fieldName === fieldName);
}
var nonMatchingGroupName = bindNot(matchingGroupName);
function matchingGroupName(testObject, groupName) {
  return testObject.groupName === groupName;
}
function nonMatchingSeverityProfile(severity, testObject) {
  return either(severity === Severity.WARNINGS, testObject.warns());
}
function hasErrorsByTestObjects(fieldName) {
  return hasFailuresByTestObjects(Severity.ERRORS, fieldName);
}
function hasFailuresByTestObjects(severityKey, fieldName) {
  var testObjects = useTestsFlat();
  return testObjects.some(function(testObject) {
    return hasFailuresByTestObject(testObject, severityKey, fieldName);
  });
}
function hasGroupFailuresByTestObjects(severityKey, groupName, fieldName) {
  var testObjects = useTestsFlat();
  return testObjects.some(function(testObject) {
    if (nonMatchingGroupName(testObject, groupName)) {
      return false;
    }
    return hasFailuresByTestObject(testObject, severityKey, fieldName);
  });
}
function hasFailuresByTestObject(testObject, severityKey, fieldName) {
  if (!testObject.hasFailures()) {
    return false;
  }
  if (nonMatchingFieldName(testObject, fieldName)) {
    return false;
  }
  if (nonMatchingSeverityProfile(severityKey, testObject)) {
    return false;
  }
  return true;
}
function optional(optionals) {
  if (isArray(optionals) || isStringValue(optionals)) {
    asArray(optionals).forEach(function(optionalField) {
      useSetOptionalField(optionalField, function() {
        return {
          type: OptionalFieldTypes.Delayed,
          applied: false,
          rule: null
        };
      });
    });
  } else {
    var _loop_1 = function(field2) {
      var value = optionals[field2];
      useSetOptionalField(field2, function() {
        return {
          type: OptionalFieldTypes.Immediate,
          rule: value,
          applied: optionalFunctionValue(value)
        };
      });
    };
    for (var field in optionals) {
      _loop_1(field);
    }
  }
}
function optionalFiedIsApplied(fieldName) {
  if (!fieldName) {
    return false;
  }
  return useOptionalField(fieldName).applied;
}
var OptionalFieldTypes;
(function(OptionalFieldTypes2) {
  OptionalFieldTypes2[OptionalFieldTypes2["Immediate"] = 0] = "Immediate";
  OptionalFieldTypes2[OptionalFieldTypes2["Delayed"] = 1] = "Delayed";
})(OptionalFieldTypes || (OptionalFieldTypes = {}));
function shouldAddValidProperty(fieldName) {
  if (optionalFiedIsApplied(fieldName)) {
    return true;
  }
  var testObjects = useTestsFlat();
  if (isEmpty(testObjects)) {
    return false;
  }
  if (hasErrorsByTestObjects(fieldName)) {
    return false;
  }
  if (hasNonOptionalIncomplete(fieldName)) {
    return false;
  }
  return noMissingTests(fieldName);
}
function shouldAddValidPropertyInGroup(groupName, fieldName) {
  if (optionalFiedIsApplied(fieldName)) {
    return true;
  }
  if (hasGroupFailuresByTestObjects(Severity.ERRORS, groupName, fieldName)) {
    return false;
  }
  if (hasNonOptionalIncompleteByGroup(groupName, fieldName)) {
    return false;
  }
  return noMissingTestsByGroup(groupName, fieldName);
}
function hasNonOptionalIncomplete(fieldName) {
  return useAllIncomplete().some(function(testObject) {
    return isTestObjectOptional(testObject, fieldName);
  });
}
function hasNonOptionalIncompleteByGroup(groupName, fieldName) {
  return useAllIncomplete().some(function(testObject) {
    if (nonMatchingGroupName(testObject, groupName)) {
      return false;
    }
    return isTestObjectOptional(testObject, fieldName);
  });
}
function isTestObjectOptional(testObject, fieldName) {
  if (nonMatchingFieldName(testObject, fieldName)) {
    return false;
  }
  return optionalFiedIsApplied(fieldName);
}
function noMissingTests(fieldName) {
  var testObjects = useTestsFlat();
  return testObjects.every(function(testObject) {
    return noMissingTestsLogic(testObject, fieldName);
  });
}
function noMissingTestsByGroup(groupName, fieldName) {
  var testObjects = useTestsFlat();
  return testObjects.every(function(testObject) {
    if (nonMatchingGroupName(testObject, groupName)) {
      return true;
    }
    return noMissingTestsLogic(testObject, fieldName);
  });
}
function noMissingTestsLogic(testObject, fieldName) {
  if (nonMatchingFieldName(testObject, fieldName)) {
    return true;
  }
  return optionalTestAwaitsResolution(testObject) || testObject.isTested() || testObject.isOmitted();
}
function optionalTestAwaitsResolution(testObject) {
  return useOptionalField(testObject.fieldName).type === OptionalFieldTypes.Delayed && testObject.awaitsResolution();
}
function genTestsSummary() {
  var testObjects = useTestsFlat();
  var summary = assign(baseStats(), {
    groups: {},
    tests: {},
    valid: false
  });
  testObjects.reduce(function(summary2, testObject) {
    appendToTest(summary2.tests, testObject);
    appendToGroup(summary2.groups, testObject);
    return summary2;
  }, summary);
  summary.valid = shouldAddValidProperty();
  return countFailures(summary);
}
function appendToTest(tests, testObject) {
  tests[testObject.fieldName] = appendTestObject(tests, testObject);
  tests[testObject.fieldName].valid = tests[testObject.fieldName].valid === false ? false : shouldAddValidProperty(testObject.fieldName);
}
function appendToGroup(groups, testObject) {
  var groupName = testObject.groupName;
  if (!groupName) {
    return;
  }
  groups[groupName] = groups[groupName] || {};
  groups[groupName][testObject.fieldName] = appendTestObject(groups[groupName], testObject);
  groups[groupName][testObject.fieldName].valid = groups[groupName][testObject.fieldName].valid === false ? false : shouldAddValidPropertyInGroup(groupName, testObject.fieldName);
}
function countFailures(summary) {
  for (var test2 in summary.tests) {
    summary.errorCount += summary.tests[test2].errorCount;
    summary.warnCount += summary.tests[test2].warnCount;
    summary.testCount += summary.tests[test2].testCount;
  }
  return summary;
}
function appendTestObject(summaryKey, testObject) {
  var fieldName = testObject.fieldName, message = testObject.message;
  summaryKey[fieldName] = summaryKey[fieldName] || baseTestStats();
  var testKey = summaryKey[fieldName];
  if (testObject.isNonActionable())
    return testKey;
  summaryKey[fieldName].testCount++;
  if (testObject.isFailing()) {
    incrementFailures(Severity.ERRORS);
  } else if (testObject.isWarning()) {
    incrementFailures(Severity.WARNINGS);
  }
  return testKey;
  function incrementFailures(severity) {
    var countKey = countKeyBySeverity(severity);
    testKey[countKey]++;
    if (message) {
      testKey[severity] = (testKey[severity] || []).concat(message);
    }
  }
}
function baseStats() {
  return {
    errorCount: 0,
    warnCount: 0,
    testCount: 0
  };
}
function baseTestStats() {
  return assign(baseStats(), {
    errors: [],
    warnings: []
  });
}
function gatherFailures(testGroup, severityKey, fieldName) {
  return fieldName ? getByFieldName(testGroup, severityKey, fieldName) : collectAll(testGroup, severityKey);
}
function getByFieldName(testGroup, severityKey, fieldName) {
  var _a;
  return ((_a = testGroup === null || testGroup === void 0 ? void 0 : testGroup[fieldName]) === null || _a === void 0 ? void 0 : _a[severityKey]) || [];
}
function collectAll(testGroup, severityKey) {
  var output = {};
  var countKey = countKeyBySeverity(severityKey);
  for (var field in testGroup) {
    if (isPositive(testGroup[field][countKey])) {
      output[field] = testGroup[field][severityKey] || [];
    }
  }
  return output;
}
function suiteSelectors(summary) {
  var selectors = {
    getErrors,
    getErrorsByGroup,
    getWarnings,
    getWarningsByGroup,
    hasErrors,
    hasErrorsByGroup,
    hasWarnings,
    hasWarningsByGroup,
    isValid,
    isValidByGroup
  };
  return selectors;
  function isValid(fieldName) {
    var _a;
    return fieldName ? Boolean((_a = summary.tests[fieldName]) === null || _a === void 0 ? void 0 : _a.valid) : summary.valid;
  }
  function isValidByGroup(groupName, fieldName) {
    var group2 = summary.groups[groupName];
    if (!group2) {
      return false;
    }
    if (fieldName) {
      return isFieldValid(group2, fieldName);
    }
    for (var fieldName_1 in group2) {
      if (!isFieldValid(group2, fieldName_1)) {
        return false;
      }
    }
    return true;
  }
  function hasWarnings(fieldName) {
    return hasFailures(summary, SeverityCount.WARN_COUNT, fieldName);
  }
  function hasErrors(fieldName) {
    return hasFailures(summary, SeverityCount.ERROR_COUNT, fieldName);
  }
  function hasWarningsByGroup(groupName, fieldName) {
    return hasFailuresByGroup(summary, SeverityCount.WARN_COUNT, groupName, fieldName);
  }
  function hasErrorsByGroup(groupName, fieldName) {
    return hasFailuresByGroup(summary, SeverityCount.ERROR_COUNT, groupName, fieldName);
  }
  function getWarnings(fieldName) {
    return getFailures(summary, Severity.WARNINGS, fieldName);
  }
  function getErrors(fieldName) {
    return getFailures(summary, Severity.ERRORS, fieldName);
  }
  function getErrorsByGroup(groupName, fieldName) {
    return getFailuresByGroup(summary, Severity.ERRORS, groupName, fieldName);
  }
  function getWarningsByGroup(groupName, fieldName) {
    return getFailuresByGroup(summary, Severity.WARNINGS, groupName, fieldName);
  }
}
function getFailures(summary, severityKey, fieldName) {
  return gatherFailures(summary.tests, severityKey, fieldName);
}
function getFailuresByGroup(summary, severityKey, groupName, fieldName) {
  return gatherFailures(summary.groups[groupName], severityKey, fieldName);
}
function isFieldValid(testContainer, fieldName) {
  var _a;
  return !!((_a = testContainer[fieldName]) === null || _a === void 0 ? void 0 : _a.valid);
}
function hasFailuresByGroup(summary, severityCount, groupName, fieldName) {
  var _a, _b;
  var group2 = summary.groups[groupName];
  if (!group2) {
    return false;
  }
  if (fieldName) {
    return isPositive((_a = group2[fieldName]) === null || _a === void 0 ? void 0 : _a[severityCount]);
  }
  for (var field in group2) {
    if (isPositive((_b = group2[field]) === null || _b === void 0 ? void 0 : _b[severityCount])) {
      return true;
    }
  }
  return false;
}
function hasFailures(summary, countKey, fieldName) {
  var _a;
  var failureCount = fieldName ? (_a = summary.tests[fieldName]) === null || _a === void 0 ? void 0 : _a[countKey] : summary[countKey] || 0;
  return isPositive(failureCount);
}
var cache$1 = createCache(1);
function produceSuiteResult() {
  var testObjects = useTestsFlat();
  var ctxRef = { stateRef: useStateRef() };
  return cache$1([testObjects], context.bind(ctxRef, function() {
    var summary = genTestsSummary();
    var suiteName = useSuiteName();
    return assign(summary, suiteSelectors(summary), {
      suiteName
    });
  }));
}
function hasRemainingTests(fieldName) {
  var allIncomplete = useAllIncomplete();
  if (isEmpty(allIncomplete)) {
    return false;
  }
  if (fieldName) {
    return allIncomplete.some(function(testObject) {
      return matchingFieldName(testObject, fieldName);
    });
  }
  return true;
}
var cache = createCache(20);
function produceFullResult() {
  var testObjects = useTestsFlat();
  var ctxRef = { stateRef: useStateRef() };
  return cache([testObjects], context.bind(ctxRef, function() {
    return assign({}, produceSuiteResult(), {
      done: context.bind(ctxRef, done)
    });
  }));
}
function shouldSkipDoneRegistration(callback, fieldName, output) {
  var _a;
  return !!(!isFunction(callback) || fieldName && numberEquals((_a = output.tests[fieldName]) === null || _a === void 0 ? void 0 : _a.testCount, 0));
}
function shouldRunDoneCallback(fieldName) {
  return !!(!hasRemainingTests() || fieldName && !hasRemainingTests(fieldName));
}
var done = function done2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var _a = args.reverse(), callback = _a[0], fieldName = _a[1];
  var output = produceFullResult();
  if (shouldSkipDoneRegistration(callback, fieldName, output)) {
    return output;
  }
  var doneCallback = function() {
    return callback(produceSuiteResult());
  };
  if (shouldRunDoneCallback(fieldName)) {
    doneCallback();
    return output;
  }
  deferDoneCallback(doneCallback, fieldName);
  return output;
};
function deferDoneCallback(doneCallback, fieldName) {
  var _a = useTestCallbacks(), setTestCallbacks = _a[1];
  setTestCallbacks(function(current) {
    if (fieldName) {
      current.fieldCallbacks[fieldName] = (current.fieldCallbacks[fieldName] || []).concat(doneCallback);
    } else {
      current.doneCallbacks.push(doneCallback);
    }
    return current;
  });
}
function omitOptionalFields() {
  var optionalFields = useOptionalFields()[0];
  if (isEmpty(optionalFields)) {
    return;
  }
  var shouldOmit = {};
  useTestsFlat().forEach(function(testObject) {
    if (hasOwnProperty(shouldOmit, testObject.fieldName)) {
      verifyAndOmit(testObject);
    } else {
      runOptionalConfig(testObject);
    }
  });
  useRefreshTestObjects();
  function verifyAndOmit(testObject) {
    if (shouldOmit[testObject.fieldName]) {
      testObject.omit();
      useSetOptionalField(testObject.fieldName, function() {
        return {
          applied: true
        };
      });
    }
  }
  function runOptionalConfig(testObject) {
    var optionalConfig = useOptionalField(testObject.fieldName);
    if (optionalConfig.type === OptionalFieldTypes.Immediate) {
      shouldOmit[testObject.fieldName] = optionalFunctionValue(optionalConfig.rule);
      verifyAndOmit(testObject);
    }
  }
}
function removeTestFromState(testObject) {
  useSetTests(function(tests) {
    return nestedArray.transform(tests, function(test2) {
      return testObject !== test2 ? test2 : null;
    });
  });
}
function runFieldCallbacks(fieldName) {
  var fieldCallbacks = useTestCallbacks()[0].fieldCallbacks;
  if (fieldName && !hasRemainingTests(fieldName) && isArray(fieldCallbacks[fieldName])) {
    callEach(fieldCallbacks[fieldName]);
  }
}
function runDoneCallbacks() {
  var doneCallbacks = useTestCallbacks()[0].doneCallbacks;
  callEach(doneCallbacks);
}
function initBus() {
  var vestBus = bus.createBus();
  vestBus.on(Events.TEST_COMPLETED, function(testObject) {
    if (testObject.isCanceled()) {
      return;
    }
    testObject.done();
    runFieldCallbacks(testObject.fieldName);
    if (!hasRemainingTests()) {
      vestBus.emit(Events.ALL_RUNNING_TESTS_FINISHED);
    }
  });
  vestBus.on(Events.SUITE_CALLBACK_DONE_RUNNING, function() {
    omitOptionalFields();
  });
  vestBus.on(Events.ALL_RUNNING_TESTS_FINISHED, function() {
    runDoneCallbacks();
  });
  vestBus.on(Events.REMOVE_FIELD, function(fieldName) {
    useEachTestObject(function(testObject) {
      if (matchingFieldName(testObject, fieldName)) {
        testObject.cancel();
        removeTestFromState(testObject);
      }
    });
  });
  vestBus.on(Events.RESET_FIELD, function(fieldName) {
    useEachTestObject(function(testObject) {
      if (matchingFieldName(testObject, fieldName)) {
        testObject.reset();
      }
    });
  });
  return vestBus;
}
function useBus() {
  var context$1 = context.useX();
  invariant(context$1.bus);
  return context$1.bus;
}
var Events;
(function(Events2) {
  Events2["TEST_COMPLETED"] = "test_completed";
  Events2["ALL_RUNNING_TESTS_FINISHED"] = "all_running_tests_finished";
  Events2["REMOVE_FIELD"] = "remove_field";
  Events2["RESET_FIELD"] = "reset_field";
  Events2["SUITE_CALLBACK_DONE_RUNNING"] = "suite_callback_done_running";
})(Events || (Events = {}));
function create() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var _a = args.reverse(), suiteCallback = _a[0], suiteName = _a[1];
  invariant(isFunction(suiteCallback), "vest.create: Expected callback to be a function.");
  var bus2 = initBus();
  var state = createState();
  var stateRef = createStateRef(state, { suiteId: seq(), suiteName });
  var ctxRef = { stateRef, bus: bus2 };
  var suite = assign(
    // Bind the suite body to the context
    context.bind(ctxRef, function() {
      var args2 = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args2[_i2] = arguments[_i2];
      }
      state.reset();
      isolate({ type: IsolateTypes.SUITE }, function() {
        suiteCallback.apply(void 0, args2);
      });
      bus2.emit(Events.SUITE_CALLBACK_DONE_RUNNING);
      return produceFullResult();
    }),
    {
      get: context.bind(ctxRef, produceSuiteResult),
      remove: context.bind(ctxRef, function(fieldName) {
        bus2.emit(Events.REMOVE_FIELD, fieldName);
      }),
      reset: state.reset,
      resetField: context.bind(ctxRef, function(fieldName) {
        bus2.emit(Events.RESET_FIELD, fieldName);
      })
    }
  );
  return suite;
}
function each(list, callback) {
  invariant(isFunction(callback), "each callback must be a function");
  isolate({ type: IsolateTypes.EACH }, function() {
    list.forEach(function(arg, index) {
      callback(arg, index);
    });
  });
}
var ERROR_HOOK_CALLED_OUTSIDE = "hook called outside of a running suite.";
function skipWhen(conditional, callback) {
  isolate({ type: IsolateTypes.SKIP_WHEN }, function() {
    context.run({
      skipped: (
        // Checking for nested conditional. If we're in a nested skipWhen,
        // we should skip the test if the parent conditional is true.
        isExcludedIndividually() || // Otherwise, we should skip the test if the conditional is true.
        optionalFunctionValue(conditional, optionalFunctionValue(produceSuiteResult))
      )
    }, function() {
      return callback();
    });
  });
}
function isExcludedIndividually() {
  return !!context.useX().skipped;
}
function only(item) {
  return addTo(0, "tests", item);
}
only.group = function(item) {
  return addTo(0, "groups", item);
};
function skip(item) {
  return addTo(1, "tests", item);
}
skip.group = function(item) {
  return addTo(1, "groups", item);
};
function isExcluded(testObject) {
  var fieldName = testObject.fieldName, groupName = testObject.groupName;
  if (isExcludedIndividually())
    return true;
  var context$1 = context.useX();
  var exclusion = context$1.exclusion;
  var inclusion = context$1.inclusion;
  var keyTests = exclusion.tests;
  var testValue = keyTests[fieldName];
  if (testValue === false)
    return true;
  var isTestIncluded = testValue === true;
  if (groupName) {
    if (isGroupExcluded(groupName)) {
      return true;
    } else if (exclusion.groups[groupName] === true) {
      if (isTestIncluded)
        return false;
      if (hasIncludedTests(keyTests))
        return true;
      return keyTests[fieldName] === false;
    }
  }
  if (isTopLevelWhenThereIsAnIncludedGroup(groupName)) {
    return true;
  }
  if (isTestIncluded)
    return false;
  if (hasIncludedTests(keyTests)) {
    return !optionalFunctionValue(inclusion[fieldName]);
  }
  return false;
}
function isGroupExcluded(groupName) {
  var context$1 = context.useX();
  var exclusion = context$1.exclusion;
  var keyGroups = exclusion.groups;
  var groupPresent = hasOwnProperty(keyGroups, groupName);
  if (groupPresent) {
    return keyGroups[groupName] === false;
  }
  return hasIncludedGroups();
}
function addTo(exclusionGroup, itemType, item) {
  var context$1 = context.useX(ERROR_HOOK_CALLED_OUTSIDE);
  if (!item) {
    return;
  }
  asArray(item).forEach(function(itemName) {
    if (!isStringValue(itemName)) {
      return;
    }
    context$1.exclusion[itemType][itemName] = exclusionGroup === 0;
  });
}
function hasIncludedTests(keyTests) {
  for (var test2 in keyTests) {
    if (keyTests[test2] === true) {
      return true;
    }
  }
  return false;
}
function isTopLevelWhenThereIsAnIncludedGroup(groupName) {
  if (!hasIncludedGroups()) {
    return false;
  }
  return !groupName;
}
function hasIncludedGroups() {
  var context$1 = context.useX();
  var exclusion = context$1.exclusion;
  for (var group2 in exclusion.groups) {
    if (exclusion.groups[group2]) {
      return true;
    }
  }
  return false;
}
function group(groupName, tests) {
  invariant(isStringValue(groupName), groupErrorMsg("name must be a string"));
  invariant(isFunction(tests), groupErrorMsg("callback must be a function"));
  isolate({ type: IsolateTypes.GROUP }, function() {
    context.run({ groupName }, tests);
  });
}
function groupErrorMsg(error) {
  return "Wrong arguments passed to group. Group ".concat(error, ".");
}
function include(fieldName) {
  var context$1 = context.useX();
  var inclusion = context$1.inclusion, exclusion = context$1.exclusion;
  invariant(isStringValue(fieldName));
  inclusion[fieldName] = defaultTo(exclusion.tests[fieldName], true);
  return { when };
  function when(condition2) {
    var context$12 = context.useX();
    var inclusion2 = context$12.inclusion, exclusion2 = context$12.exclusion;
    inclusion2[fieldName] = function() {
      if (hasOwnProperty(exclusion2.tests, fieldName)) {
        return defaultTo(exclusion2.tests[fieldName], true);
      }
      if (isStringValue(condition2)) {
        return Boolean(exclusion2.tests[condition2]);
      }
      return optionalFunctionValue(condition2, optionalFunctionValue(produceSuiteResult));
    };
  }
}
function eager() {
  setMode(Modes.EAGER);
}
function shouldSkipBasedOnMode(testObject) {
  return isEager() && hasErrorsByTestObjects(testObject.fieldName);
}
function isEager() {
  return isMode(Modes.EAGER);
}
function isMode(mode) {
  var currentMode = context.useX().mode;
  return currentMode[0] === mode;
}
function setMode(nextMode) {
  var mode = context.useX().mode;
  mode[0] = nextMode;
}
function omitWhen(conditional, callback) {
  isolate({ type: IsolateTypes.OMIT_WHEN }, function() {
    context.run({
      omitted: inActiveOmitWhen() || optionalFunctionValue(conditional, optionalFunctionValue(produceSuiteResult))
    }, function() {
      return callback();
    });
  });
}
function inActiveOmitWhen() {
  return !!context.useX().omitted;
}
function __spreadArray2(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function isSameProfileTest(testObject1, testObject2) {
  return testObject1.fieldName === testObject2.fieldName && testObject1.groupName === testObject2.groupName;
}
function cancelOverriddenPendingTest(prevRunTestObject, currentRunTestObject) {
  if (currentRunTestObject !== prevRunTestObject && isSameProfileTest(prevRunTestObject, currentRunTestObject) && prevRunTestObject.isPending()) {
    prevRunTestObject.cancel();
  }
}
function runAsyncTest(testObject) {
  var asyncTest = testObject.asyncTest, message = testObject.message;
  if (!isPromise(asyncTest))
    return;
  var emit = useBus().emit;
  var stateRef = useStateRef();
  var done3 = context.bind({ stateRef }, function() {
    useRefreshTestObjects();
    emit(Events.TEST_COMPLETED, testObject);
  });
  var fail = context.bind({ stateRef }, function(rejectionMessage) {
    if (testObject.isCanceled()) {
      return;
    }
    testObject.message = isStringValue(rejectionMessage) ? rejectionMessage : message;
    testObject.fail();
    done3();
  });
  asyncTest.then(done3, fail);
}
function runSyncTest(testObject) {
  return context.run({ currentTest: testObject }, function() {
    return testObject.run();
  });
}
function registerTest(testObject) {
  var bus2 = useBus();
  var result = runSyncTest(testObject);
  try {
    if (isPromise(result)) {
      testObject.asyncTest = result;
      testObject.setPending();
      runAsyncTest(testObject);
    } else {
      bus2.emit(Events.TEST_COMPLETED, testObject);
    }
  } catch (e) {
    throw new Error("Unexpected error encountered during test registration.\n      Test Object: ".concat(JSON.stringify(testObject), ".\n      Error: ").concat(e, "."));
  }
}
function useTestAtCursor(newTestObject) {
  var testObjects = useTestObjects()[0];
  var prevTests = testObjects.prev;
  if (isEmpty(prevTests)) {
    useSetTestAtCursor(newTestObject);
    return newTestObject;
  }
  var prevTest = useGetTestAtCursor(prevTests);
  if (!isNullish(newTestObject.key)) {
    var nextTest_1 = handleKeyTest(newTestObject.key, newTestObject);
    useSetTestAtCursor(nextTest_1);
    return nextTest_1;
  }
  if (testReorderDetected(prevTest, newTestObject)) {
    throwTestOrderError(prevTest, newTestObject);
    removeAllNextTestsInIsolate();
    prevTest = null;
  }
  var nextTest = defaultTo(prevTest, newTestObject);
  useSetTestAtCursor(nextTest);
  return nextTest;
}
function removeAllNextTestsInIsolate() {
  var cursorAt = useCursor().current();
  useSetTests(function(current) {
    current.splice(cursorAt);
    return current;
  });
}
function useSetTestAtCursor(testObject) {
  var cursorPath = useCurrentPath();
  useSetTests(function(tests) {
    return nestedArray.setValueAtPath(tests, cursorPath, testObject);
  });
}
function useGetTestAtCursor(tests) {
  var cursorPath = useCurrentPath();
  return nestedArray.valueAtPath(tests, cursorPath);
}
function testReorderDetected(prevTest, newTest) {
  return isNotEmpty(prevTest) && !isSameProfileTest(prevTest, newTest);
}
function throwTestOrderError(prevTest, newTestObject) {
  if (shouldAllowReorder()) {
    return;
  }
  deferThrow("Vest Critical Error: Tests called in different order than previous run.\n    expected: ".concat(prevTest.fieldName, "\n    received: ").concat(newTestObject.fieldName, `
    This can happen on one of two reasons:
    1. You're using if/else statements to conditionally select tests. Instead, use "skipWhen".
    2. You are iterating over a list of tests, and their order changed. Use "each" and a custom key prop so that Vest retains their state.`));
}
function handleKeyTest(key, newTestObject) {
  var prevTestByKey = usePrevTestByKey(key);
  var nextTest = newTestObject;
  if (prevTestByKey) {
    nextTest = prevTestByKey;
  }
  useRetainTestKey(key, nextTest);
  return nextTest;
}
function registerPrevRunTest(testObject) {
  var cursor = useCursor();
  if (shouldSkipBasedOnMode(testObject)) {
    testObject.skip();
    useTestAtCursor(testObject);
    cursor.next();
    return testObject;
  }
  var prevRunTest = useTestAtCursor(testObject);
  if (inActiveOmitWhen() || optionalFiedIsApplied(testObject.fieldName)) {
    prevRunTest.omit();
    cursor.next();
    return prevRunTest;
  }
  if (isExcluded(testObject)) {
    prevRunTest.skip(isExcludedIndividually());
    cursor.next();
    return prevRunTest;
  }
  cancelOverriddenPendingTest(prevRunTest, testObject);
  useSetTestAtCursor(testObject);
  registerTestObjectByTier(testObject);
  cursor.next();
  return testObject;
}
function registerTestObjectByTier(testObject) {
  if (testObject.isUntested()) {
    registerTest(testObject);
  } else if (isPromise(testObject.asyncTest)) {
    testObject.setPending();
    runAsyncTest(testObject);
  }
}
function testMemo(test2) {
  var cache2 = createCache(10);
  function memo(fieldName) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var cursorAt = useCursor().current();
    var _a = args.reverse(), deps = _a[0], testFn = _a[1], msg = _a[2];
    var dependencies = [useSuiteId(), fieldName, cursorAt].concat(deps);
    var cached = cache2.get(dependencies);
    if (isNull(cached)) {
      return cache2(dependencies, function() {
        return test2(fieldName, msg, testFn);
      });
    }
    if (cached[1].isCanceled()) {
      cache2.invalidate(dependencies);
      return cache2(dependencies, function() {
        return test2(fieldName, msg, testFn);
      });
    }
    return registerPrevRunTest(cached[1]);
  }
  return memo;
}
function testBase(fieldName) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var _a = isFunction(args[1]) ? args : __spreadArray2([void 0], args, true), message = _a[0], testFn = _a[1], key = _a[2];
  invariant(isStringValue(fieldName), incompatibleParamsError("fieldName", "string"));
  invariant(isFunction(testFn), incompatibleParamsError("Test callback", "function"));
  var context$1 = context.useX();
  var testObject = new VestTest(fieldName, testFn, {
    message,
    groupName: context$1.groupName,
    key
  });
  return registerPrevRunTest(testObject);
}
var test = assign(testBase, {
  memo: testMemo(testBase)
});
function incompatibleParamsError(name, expected) {
  return "Incompatible params passed to test function. ".concat(name, " must be a ").concat(expected);
}
var ERROR_OUTSIDE_OF_TEST = "warn hook called outside of a test callback. It won't have an effect.";
function warn() {
  var ctx2 = context.useX("warn " + ERROR_HOOK_CALLED_OUTSIDE);
  invariant(ctx2.currentTest, ERROR_OUTSIDE_OF_TEST);
  ctx2.currentTest.warn();
}
var VERSION = "4.6.11";
export {
  VERSION,
  context,
  create,
  each,
  eager,
  enforce,
  group,
  include,
  omitWhen,
  only,
  optional,
  skip,
  skipWhen,
  suiteSelectors,
  test,
  warn
};
//# sourceMappingURL=vest.js.map
