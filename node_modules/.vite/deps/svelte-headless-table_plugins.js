import {
  DataBodyCell,
  DisplayBodyRow,
  getSubRows,
  nonNull,
  nonUndefined,
  sum
} from "./chunk-WBWEWY3L.js";
import {
  derived,
  readable,
  writable
} from "./chunk-E6ZP6LG5.js";
import {
  get_store_value
} from "./chunk-RVLVW3YK.js";
import "./chunk-TCQZMY3T.js";

// node_modules/svelte-keyed/dist/index.es.js
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var getTokens = function(key) {
  var keyWithoutBracket = key.replace(/\[(\d+)\]/g, ".$1");
  if (keyWithoutBracket.startsWith(".")) {
    keyWithoutBracket = keyWithoutBracket.slice(1);
  }
  return keyWithoutBracket.split(".");
};
var getNested = function(root, keyTokens) {
  var current = root;
  for (var _i = 0, keyTokens_1 = keyTokens; _i < keyTokens_1.length; _i++) {
    var key = keyTokens_1[_i];
    if (current == null) {
      return void 0;
    }
    current = current[key];
  }
  return current;
};
var clonedWithPrototype = function(source) {
  var clone = Object.create(source);
  Object.assign(clone, source);
  return clone;
};
function keyed(parent, path) {
  var keyTokens = getTokens(path);
  if (keyTokens.some(function(token) {
    return token === "__proto__";
  })) {
    throw new Error('key cannot include "__proto__"');
  }
  var branchTokens = keyTokens.slice(0, keyTokens.length - 1);
  var leafToken = keyTokens[keyTokens.length - 1];
  var keyedValue = derived(parent, function($parent) {
    return getNested($parent, keyTokens);
  });
  var set = function(value) {
    parent.update(function($parent) {
      if ($parent == null) {
        return $parent;
      }
      var newParent = Array.isArray($parent) ? __spreadArray([], $parent, true) : clonedWithPrototype($parent);
      getNested(newParent, branchTokens)[leafToken] = value;
      return newParent;
    });
  };
  var update = function(fn) {
    parent.update(function($parent) {
      if ($parent == null) {
        return $parent;
      }
      var newValue = fn(getNested($parent, keyTokens));
      var newParent = Array.isArray($parent) ? __spreadArray([], $parent, true) : clonedWithPrototype($parent);
      getNested(newParent, branchTokens)[leafToken] = newValue;
      return newParent;
    });
  };
  return {
    subscribe: keyedValue.subscribe,
    set,
    update
  };
}

// node_modules/svelte-headless-table/plugins/addColumnFilters.js
var getFilteredRows = (rows, filterValues, columnOptions) => {
  const $filteredRows = rows.map((row) => {
    const { subRows } = row;
    if (subRows === void 0) {
      return row;
    }
    const filteredSubRows = getFilteredRows(subRows, filterValues, columnOptions);
    const clonedRow = row.clone();
    clonedRow.subRows = filteredSubRows;
    return clonedRow;
  }).filter((row) => {
    var _a;
    if ((((_a = row.subRows) == null ? void 0 : _a.length) ?? 0) !== 0) {
      return true;
    }
    for (const [columnId, columnOption] of Object.entries(columnOptions)) {
      const bodyCell = row.cellForId[columnId];
      if (!bodyCell.isData()) {
        continue;
      }
      const { value } = bodyCell;
      const filterValue = filterValues[columnId];
      if (filterValue === void 0) {
        continue;
      }
      const isMatch = columnOption.fn({ value, filterValue });
      if (!isMatch) {
        return false;
      }
    }
    return true;
  });
  return $filteredRows;
};
var addColumnFilters = ({ serverSide = false } = {}) => ({ columnOptions, tableState }) => {
  const filterValues = writable({});
  const preFilteredRows = writable([]);
  const filteredRows = writable([]);
  const pluginState = { filterValues, preFilteredRows };
  const deriveRows = (rows) => {
    return derived([rows, filterValues], ([$rows, $filterValues]) => {
      preFilteredRows.set($rows);
      if (serverSide) {
        filteredRows.set($rows);
        return $rows;
      }
      const _filteredRows = getFilteredRows($rows, $filterValues, columnOptions);
      filteredRows.set(_filteredRows);
      return _filteredRows;
    });
  };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "thead.tr.th": (headerCell) => {
        const filterValue = keyed(filterValues, headerCell.id);
        const props = derived([], () => {
          const columnOption = columnOptions[headerCell.id];
          if (columnOption === void 0) {
            return void 0;
          }
          filterValue.set(columnOption.initialFilterValue);
          const preFilteredValues = derived(preFilteredRows, ($rows) => {
            if (headerCell.isData()) {
              return $rows.map((row) => {
                const cell = row.cellForId[headerCell.id];
                return cell == null ? void 0 : cell.value;
              });
            }
            return [];
          });
          const values = derived(filteredRows, ($rows) => {
            if (headerCell.isData()) {
              return $rows.map((row) => {
                const cell = row.cellForId[headerCell.id];
                return cell == null ? void 0 : cell.value;
              });
            }
            return [];
          });
          const render = columnOption.render({
            id: headerCell.id,
            filterValue,
            ...tableState,
            values,
            preFilteredRows,
            preFilteredValues
          });
          return { render };
        });
        return { props };
      }
    }
  };
};
var matchFilter = ({ filterValue, value }) => {
  if (filterValue === void 0) {
    return true;
  }
  return filterValue === value;
};
var textPrefixFilter = ({ filterValue, value }) => {
  if (filterValue === "") {
    return true;
  }
  return String(value).toLowerCase().startsWith(String(filterValue).toLowerCase());
};
var numberRangeFilter = ({ filterValue: [min, max], value }) => {
  return (min ?? -Infinity) <= value && value <= (max ?? Infinity);
};

// node_modules/svelte-headless-table/plugins/addColumnOrder.js
var addColumnOrder = ({ initialColumnIdOrder = [], hideUnspecifiedColumns = false } = {}) => () => {
  const columnIdOrder = writable(initialColumnIdOrder);
  const pluginState = { columnIdOrder };
  const deriveFlatColumns = (flatColumns) => {
    return derived([flatColumns, columnIdOrder], ([$flatColumns, $columnIdOrder]) => {
      const _flatColumns = [...$flatColumns];
      const orderedFlatColumns = [];
      $columnIdOrder.forEach((id) => {
        const colIdx = _flatColumns.findIndex((c) => c.id === id);
        orderedFlatColumns.push(..._flatColumns.splice(colIdx, 1));
      });
      if (!hideUnspecifiedColumns) {
        orderedFlatColumns.push(..._flatColumns);
      }
      return orderedFlatColumns;
    });
  };
  return {
    pluginState,
    deriveFlatColumns
  };
};

// node_modules/svelte-headless-table/utils/store.js
var isReadable = (value) => {
  return (value == null ? void 0 : value.subscribe) instanceof Function;
};
var Undefined = readable(void 0);
var arraySetStore = (initial = [], { isEqual = (a, b) => a === b } = {}) => {
  const { subscribe, update, set } = writable(initial);
  const toggle = (item, { clearOthers = false } = {}) => {
    update(($arraySet) => {
      const index = $arraySet.findIndex(($item) => isEqual($item, item));
      if (index === -1) {
        if (clearOthers) {
          return [item];
        }
        return [...$arraySet, item];
      }
      if (clearOthers) {
        return [];
      }
      return [...$arraySet.slice(0, index), ...$arraySet.slice(index + 1)];
    });
  };
  const add = (item) => {
    update(($arraySet) => {
      const index = $arraySet.findIndex(($item) => isEqual($item, item));
      if (index === -1) {
        return [...$arraySet, item];
      }
      return $arraySet;
    });
  };
  const remove = (item) => {
    update(($arraySet) => {
      const index = $arraySet.findIndex(($item) => isEqual($item, item));
      if (index === -1) {
        return $arraySet;
      }
      return [...$arraySet.slice(0, index), ...$arraySet.slice(index + 1)];
    });
  };
  const clear = () => {
    set([]);
  };
  return {
    subscribe,
    update,
    set,
    toggle,
    add,
    remove,
    clear
  };
};
var recordSetStore = (initial = {}) => {
  const withFalseRemoved = (record) => {
    return Object.fromEntries(Object.entries(record).filter(([, v]) => v));
  };
  const { subscribe, update, set } = writable(withFalseRemoved(initial));
  const updateAndRemoveFalse = (fn) => {
    update(($recordSet) => {
      const newRecordSet = fn($recordSet);
      return withFalseRemoved(newRecordSet);
    });
  };
  const toggle = (item) => {
    update(($recordSet) => {
      if ($recordSet[item] === true) {
        delete $recordSet[item];
        return $recordSet;
      }
      return {
        ...$recordSet,
        [item]: true
      };
    });
  };
  const add = (item) => {
    update(($recordSet) => ({
      ...$recordSet,
      [item]: true
    }));
  };
  const addAll = (items) => {
    update(($recordSet) => ({
      ...$recordSet,
      ...Object.fromEntries(items.map((item) => [item, true]))
    }));
  };
  const remove = (item) => {
    update(($recordSet) => {
      delete $recordSet[item];
      return $recordSet;
    });
  };
  const removeAll = (items) => {
    update(($recordSet) => {
      for (const item of items) {
        delete $recordSet[item];
      }
      return $recordSet;
    });
  };
  const clear = () => {
    set({});
  };
  return {
    subscribe,
    update: updateAndRemoveFalse,
    set: (newValue) => updateAndRemoveFalse(() => newValue),
    toggle,
    add,
    addAll,
    remove,
    removeAll,
    clear
  };
};

// node_modules/svelte-headless-table/plugins/addDataExport.js
var getObjectsFromRows = (rows, ids, childrenKey) => {
  return rows.map((row) => {
    const dataObject = Object.fromEntries(ids.map((id) => {
      const cell = row.cellForId[id];
      if (cell.isData()) {
        return [id, cell.value];
      }
      if (cell.isDisplay() && cell.column.data !== void 0) {
        let data = cell.column.data(cell, row.state);
        if (isReadable(data)) {
          data = get_store_value(data);
        }
        return [id, data];
      }
      return [id, null];
    }));
    if (row.subRows !== void 0) {
      dataObject[childrenKey] = getObjectsFromRows(row.subRows, ids, childrenKey);
    }
    return dataObject;
  });
};
var getCsvFromRows = (rows, ids) => {
  const dataLines = rows.map((row) => {
    const line = ids.map((id) => {
      const cell = row.cellForId[id];
      if (cell.isData()) {
        return cell.value;
      }
      if (cell.isDisplay() && cell.column.data !== void 0) {
        let data = cell.column.data(cell, row.state);
        if (isReadable(data)) {
          data = get_store_value(data);
        }
        return data;
      }
      return null;
    });
    return line.join(",");
  });
  const headerLine = ids.join(",");
  return headerLine + "\n" + dataLines.join("\n");
};
var addDataExport = ({ format = "object", childrenKey = "children" } = {}) => ({ tableState, columnOptions }) => {
  const excludedIds = Object.entries(columnOptions).filter(([, option]) => option.exclude === true).map(([columnId]) => columnId);
  const { visibleColumns, rows } = tableState;
  const exportedIds = derived(visibleColumns, ($visibleColumns) => $visibleColumns.map((c) => c.id).filter((id) => !excludedIds.includes(id)));
  const exportedData = derived([rows, exportedIds], ([$rows, $exportedIds]) => {
    switch (format) {
      case "json":
        return JSON.stringify(getObjectsFromRows($rows, $exportedIds, childrenKey));
      case "csv":
        return getCsvFromRows($rows, $exportedIds);
      default:
        return getObjectsFromRows($rows, $exportedIds, childrenKey);
    }
  });
  const pluginState = { exportedData };
  return {
    pluginState
  };
};

// node_modules/svelte-headless-table/plugins/addExpandedRows.js
var withExpandedRows = (row, expandedIds) => {
  if (row.subRows === void 0) {
    return [row];
  }
  if (expandedIds[row.id] !== true) {
    return [row];
  }
  const expandedSubRows = row.subRows.flatMap((subRow) => withExpandedRows(subRow, expandedIds));
  return [row, ...expandedSubRows];
};
var addExpandedRows = ({ initialExpandedIds = {} } = {}) => () => {
  const expandedIds = recordSetStore(initialExpandedIds);
  const getRowState = (row) => {
    var _a;
    const isExpanded = keyed(expandedIds, row.id);
    const canExpand = readable((((_a = row.subRows) == null ? void 0 : _a.length) ?? 0) > 0);
    const subRowExpandedIds = derived(expandedIds, ($expandedIds) => {
      return Object.entries($expandedIds).filter(([id, expanded]) => id.startsWith(`${row.id}>`) && expanded);
    });
    const isAllSubRowsExpanded = derived(subRowExpandedIds, ($subRowExpandedIds) => {
      if (row.subRows === void 0) {
        return true;
      }
      const expandableSubRows = row.subRows.filter((subRow) => subRow.subRows !== void 0);
      return $subRowExpandedIds.length === expandableSubRows.length;
    });
    return {
      isExpanded,
      canExpand,
      isAllSubRowsExpanded
    };
  };
  const pluginState = { expandedIds, getRowState };
  const deriveRows = (rows) => {
    return derived([rows, expandedIds], ([$rows, $expandedIds]) => {
      return $rows.flatMap((row) => {
        return withExpandedRows(row, $expandedIds);
      });
    });
  };
  return {
    pluginState,
    deriveRows
  };
};

// node_modules/svelte-headless-table/plugins/addFlatten.js
var getFlattenedRows = (rows, depth) => {
  if (depth === 0)
    return rows;
  const flattenedRows = [];
  for (const row of rows) {
    if (row.subRows === void 0)
      continue;
    flattenedRows.push(...getFlattenedRows(row.subRows, depth - 1));
  }
  return flattenedRows;
};
var addFlatten = ({ initialDepth = 0 } = {}) => () => {
  const depth = writable(initialDepth);
  const pluginState = { depth };
  const deriveRows = (rows) => {
    return derived([rows, depth], ([$rows, $depth]) => {
      return getFlattenedRows($rows, $depth);
    });
  };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "tbody.tr.td": () => {
        const props = derived([], () => {
          const flatten = ($depth) => {
            depth.set($depth);
          };
          const unflatten = () => flatten(0);
          return { flatten, unflatten };
        });
        return { props };
      }
    }
  };
};

// node_modules/svelte-headless-table/plugins/addGridLayout.js
var addGridLayout = () => ({ tableState }) => {
  const pluginState = {};
  const deriveTableAttrs = (attrs) => {
    return derived([attrs, tableState.visibleColumns], ([$attrs, $visibleColumns]) => {
      return {
        ...$attrs,
        style: {
          display: "grid",
          "grid-template-columns": `repeat(${$visibleColumns.length}, auto)`
        }
      };
    });
  };
  const deriveTableHeadAttrs = (attrs) => {
    return derived(attrs, ($attrs) => {
      return {
        ...$attrs,
        style: {
          display: "contents"
        }
      };
    });
  };
  const deriveTableBodyAttrs = (attrs) => {
    return derived(attrs, ($attrs) => {
      return {
        ...$attrs,
        style: {
          display: "contents"
        }
      };
    });
  };
  return {
    pluginState,
    deriveTableAttrs,
    deriveTableHeadAttrs,
    deriveTableBodyAttrs,
    hooks: {
      "thead.tr": () => {
        const attrs = derived([], () => {
          return {
            style: {
              display: "contents"
            }
          };
        });
        return { attrs };
      },
      "thead.tr.th": (cell) => {
        const attrs = derived([], () => {
          return {
            style: {
              "grid-column": `${cell.colstart + 1} / span ${cell.colspan}`
            }
          };
        });
        return { attrs };
      },
      "tbody.tr": () => {
        const attrs = derived([], () => {
          return {
            style: {
              display: "contents"
            }
          };
        });
        return { attrs };
      }
    }
  };
};

// node_modules/svelte-headless-table/utils/event.js
var isShiftClick = (event) => {
  if (!(event instanceof MouseEvent))
    return false;
  return event.shiftKey;
};

// node_modules/svelte-headless-table/plugins/addGroupBy.js
var getIdPrefix = (id) => {
  const prefixTokens = id.split(">").slice(0, -1);
  if (prefixTokens.length === 0) {
    return "";
  }
  return `${prefixTokens.join(">")}>`;
};
var deepenIdAndDepth = (row, parentId) => {
  var _a;
  row.id = `${parentId}>${row.id}`;
  row.depth = row.depth + 1;
  (_a = row.subRows) == null ? void 0 : _a.forEach((subRow) => deepenIdAndDepth(subRow, parentId));
};
var getGroupedRows = (rows, groupByIds, columnOptions, { repeatCellIds, aggregateCellIds, groupCellIds, allGroupByIds }) => {
  if (groupByIds.length === 0) {
    return rows;
  }
  if (rows.length === 0) {
    return rows;
  }
  const idPrefix = getIdPrefix(rows[0].id);
  const [groupById, ...restIds] = groupByIds;
  const subRowsForGroupOnValue = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const cell = row.cellForId[groupById];
    if (!cell.isData()) {
      break;
    }
    const columnOption = columnOptions[groupById] ?? {};
    const { getGroupOn } = columnOption;
    const groupOnValue = (getGroupOn == null ? void 0 : getGroupOn(cell.value)) ?? cell.value;
    if (typeof groupOnValue === "function" || typeof groupOnValue === "object") {
      console.warn(`Missing \`getGroupOn\` column option to aggregate column "${groupById}" with object values`);
    }
    const subRows = subRowsForGroupOnValue.get(groupOnValue) ?? [];
    subRowsForGroupOnValue.set(groupOnValue, [...subRows, row]);
  }
  const groupedRows = [];
  let groupRowIdx = 0;
  for (const [groupOnValue, subRows] of subRowsForGroupOnValue.entries()) {
    const firstRow = subRows[0];
    const groupRow = new DisplayBodyRow({
      id: `${idPrefix}${groupRowIdx++}`,
      // TODO Differentiate data rows and grouped rows.
      depth: firstRow.depth,
      cells: [],
      cellForId: {}
    });
    const groupRowCellForId = Object.fromEntries(Object.entries(firstRow.cellForId).map(([id, cell]) => {
      if (id === groupById) {
        const newCell2 = new DataBodyCell({
          column: cell.column,
          row: groupRow,
          value: groupOnValue
        });
        return [id, newCell2];
      }
      const columnCells = subRows.map((row) => row.cellForId[id]).filter(nonUndefined);
      if (!columnCells[0].isData()) {
        const clonedCell = columnCells[0].clone();
        clonedCell.row = groupRow;
        return [id, clonedCell];
      }
      const { cell: label, getAggregateValue } = columnOptions[id] ?? {};
      const columnValues = columnCells.map((cell2) => cell2.value);
      const value = getAggregateValue === void 0 ? "" : getAggregateValue(columnValues);
      const newCell = new DataBodyCell({
        column: cell.column,
        row: groupRow,
        value,
        label
      });
      return [id, newCell];
    }));
    const groupRowCells = firstRow.cells.map((cell) => {
      return groupRowCellForId[cell.id];
    });
    groupRow.cellForId = groupRowCellForId;
    groupRow.cells = groupRowCells;
    const groupRowSubRows = subRows.map((subRow) => {
      const clonedSubRow = subRow.clone({ includeCells: true, includeSubRows: true });
      deepenIdAndDepth(clonedSubRow, groupRow.id);
      return clonedSubRow;
    });
    groupRow.subRows = getGroupedRows(groupRowSubRows, restIds, columnOptions, {
      repeatCellIds,
      aggregateCellIds,
      groupCellIds,
      allGroupByIds
    });
    groupedRows.push(groupRow);
    groupRow.cells.forEach((cell) => {
      if (cell.id === groupById) {
        groupCellIds[cell.rowColId()] = true;
      } else {
        aggregateCellIds[cell.rowColId()] = true;
      }
    });
    groupRow.subRows.forEach((subRow) => {
      subRow.parentRow = groupRow;
      subRow.cells.forEach((cell) => {
        if (allGroupByIds.includes(cell.id) && groupCellIds[cell.rowColId()] !== true) {
          repeatCellIds[cell.rowColId()] = true;
        }
      });
    });
  }
  return groupedRows;
};
var addGroupBy = ({ initialGroupByIds = [], disableMultiGroup = false, isMultiGroupEvent = isShiftClick } = {}) => ({ columnOptions }) => {
  const disabledGroupIds = Object.entries(columnOptions).filter(([, option]) => option.disable === true).map(([columnId]) => columnId);
  const groupByIds = arraySetStore(initialGroupByIds);
  const repeatCellIds = writable({});
  const aggregateCellIds = writable({});
  const groupCellIds = writable({});
  const pluginState = {
    groupByIds
  };
  const deriveRows = (rows) => {
    return derived([rows, groupByIds], ([$rows, $groupByIds]) => {
      const $repeatCellIds = {};
      const $aggregateCellIds = {};
      const $groupCellIds = {};
      const $groupedRows = getGroupedRows($rows, $groupByIds, columnOptions, {
        repeatCellIds: $repeatCellIds,
        aggregateCellIds: $aggregateCellIds,
        groupCellIds: $groupCellIds,
        allGroupByIds: $groupByIds
      });
      repeatCellIds.set($repeatCellIds);
      aggregateCellIds.set($aggregateCellIds);
      groupCellIds.set($groupCellIds);
      return $groupedRows;
    });
  };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "thead.tr.th": (cell) => {
        const disabled = disabledGroupIds.includes(cell.id) || !cell.isData();
        const props = derived(groupByIds, ($groupByIds) => {
          const grouped = $groupByIds.includes(cell.id);
          const toggle = (event) => {
            if (!cell.isData())
              return;
            if (disabled)
              return;
            groupByIds.toggle(cell.id, {
              clearOthers: disableMultiGroup || !isMultiGroupEvent(event)
            });
          };
          const clear = () => {
            groupByIds.remove(cell.id);
          };
          return {
            grouped,
            toggle,
            clear,
            disabled
          };
        });
        return { props };
      },
      "tbody.tr.td": (cell) => {
        const props = derived([repeatCellIds, aggregateCellIds, groupCellIds], ([$repeatCellIds, $aggregateCellIds, $groupCellIds]) => {
          return {
            repeated: $repeatCellIds[cell.rowColId()] === true,
            aggregated: $aggregateCellIds[cell.rowColId()] === true,
            grouped: $groupCellIds[cell.rowColId()] === true
          };
        });
        return { props };
      }
    }
  };
};

// node_modules/svelte-headless-table/plugins/addHiddenColumns.js
var addHiddenColumns = ({ initialHiddenColumnIds = [] } = {}) => () => {
  const hiddenColumnIds = writable(initialHiddenColumnIds);
  const pluginState = { hiddenColumnIds };
  const deriveFlatColumns = (flatColumns) => {
    return derived([flatColumns, hiddenColumnIds], ([$flatColumns, $hiddenColumnIds]) => {
      if ($hiddenColumnIds.length === 0) {
        return $flatColumns;
      }
      return $flatColumns.filter((c) => !$hiddenColumnIds.includes(c.id));
    });
  };
  return {
    pluginState,
    deriveFlatColumns
  };
};

// node_modules/svelte-headless-table/plugins/addPagination.js
var MIN_PAGE_SIZE = 1;
var createPageStore = ({ items, initialPageSize, initialPageIndex, serverSide }) => {
  const pageSize = writable(initialPageSize);
  const updatePageSize = (fn) => {
    pageSize.update(($pageSize) => {
      const newPageSize = fn($pageSize);
      return Math.max(newPageSize, MIN_PAGE_SIZE);
    });
  };
  const setPageSize = (newPageSize) => updatePageSize(() => newPageSize);
  const pageIndex = writable(initialPageIndex);
  function calcPageCountAndLimitIndex([$pageSize, $itemCount]) {
    const $pageCount = Math.ceil($itemCount / $pageSize);
    pageIndex.update(($pageIndex) => {
      if ($pageCount > 0 && $pageIndex >= $pageCount) {
        return $pageCount - 1;
      }
      return $pageIndex;
    });
    return $pageCount;
  }
  const serverItemCount = writable(0);
  let pageCount;
  if (serverSide) {
    pageCount = derived([pageSize, serverItemCount], calcPageCountAndLimitIndex);
  } else {
    const itemCount = derived(items, ($items) => $items.length);
    pageCount = derived([pageSize, itemCount], calcPageCountAndLimitIndex);
  }
  const hasPreviousPage = derived(pageIndex, ($pageIndex) => {
    return $pageIndex > 0;
  });
  const hasNextPage = derived([pageIndex, pageCount], ([$pageIndex, $pageCount]) => {
    return $pageIndex < $pageCount - 1;
  });
  return {
    pageSize: {
      subscribe: pageSize.subscribe,
      update: updatePageSize,
      set: setPageSize
    },
    pageIndex,
    pageCount,
    serverItemCount,
    hasPreviousPage,
    hasNextPage
  };
};
var addPagination = ({ initialPageIndex = 0, initialPageSize = 10, serverSide = false } = {}) => () => {
  const prePaginatedRows = writable([]);
  const paginatedRows = writable([]);
  const { pageSize, pageIndex, pageCount, serverItemCount, hasPreviousPage, hasNextPage } = createPageStore({
    items: prePaginatedRows,
    initialPageIndex,
    initialPageSize,
    serverSide
  });
  const pluginState = {
    pageSize,
    pageIndex,
    pageCount,
    serverItemCount,
    hasPreviousPage,
    hasNextPage
  };
  const derivePageRows = (rows) => {
    return derived([rows, pageSize, pageIndex], ([$rows, $pageSize, $pageIndex]) => {
      prePaginatedRows.set($rows);
      if (serverSide) {
        paginatedRows.set($rows);
        return $rows;
      }
      const startIdx = $pageIndex * $pageSize;
      const _paginatedRows = $rows.slice(startIdx, startIdx + $pageSize);
      paginatedRows.set(_paginatedRows);
      return _paginatedRows;
    });
  };
  return {
    pluginState,
    derivePageRows
  };
};

// node_modules/svelte-headless-table/plugins/addResizedColumns.js
var getDragXPos = (event) => {
  if (event instanceof MouseEvent)
    return event.clientX;
  if (event instanceof TouchEvent)
    return event.targetTouches[0].pageX;
  return 0;
};
var isCellDisabled = (cell, disabledIds) => {
  if (disabledIds.includes(cell.id))
    return true;
  if (cell.isGroup() && cell.ids.every((id) => disabledIds.includes(id))) {
    return true;
  }
  return false;
};
var addResizedColumns = ({ onResizeEnd } = {}) => ({ columnOptions }) => {
  const disabledResizeIds = Object.entries(columnOptions).filter(([, option]) => option.disable === true).map(([columnId]) => columnId);
  const initialWidths = Object.fromEntries(Object.entries(columnOptions).filter(([, option]) => option.initialWidth !== void 0).map(([columnId, { initialWidth }]) => [columnId, initialWidth]));
  const columnsWidthState = writable({
    current: initialWidths,
    start: {}
  });
  const columnWidths = keyed(columnsWidthState, "current");
  const pluginState = { columnWidths };
  const dragStartXPosForId = {};
  const nodeForId = {};
  return {
    pluginState,
    hooks: {
      "thead.tr.th": (cell) => {
        const dragStart = (event) => {
          if (isCellDisabled(cell, disabledResizeIds))
            return;
          const { target } = event;
          if (target === null)
            return;
          event.stopPropagation();
          event.preventDefault();
          dragStartXPosForId[cell.id] = getDragXPos(event);
          columnsWidthState.update(($columnsWidthState) => {
            const $updatedState = {
              ...$columnsWidthState,
              start: { ...$columnsWidthState.start }
            };
            if (cell.isGroup()) {
              cell.ids.forEach((id) => {
                $updatedState.start[id] = $columnsWidthState.current[id];
              });
            } else {
              $updatedState.start[cell.id] = $columnsWidthState.current[cell.id];
            }
            return $updatedState;
          });
          if (event instanceof MouseEvent) {
            window.addEventListener("mousemove", dragMove);
            window.addEventListener("mouseup", dragEnd);
          } else {
            window.addEventListener("touchmove", dragMove);
            window.addEventListener("touchend", dragEnd);
          }
        };
        const dragMove = (event) => {
          event.stopPropagation();
          event.preventDefault();
          const deltaWidth = getDragXPos(event) - dragStartXPosForId[cell.id];
          columnsWidthState.update(($columnsWidthState) => {
            const $updatedState = {
              ...$columnsWidthState,
              current: { ...$columnsWidthState.current }
            };
            if (cell.isGroup()) {
              const enabledIds = cell.ids.filter((id) => !disabledResizeIds.includes(id));
              const totalStartWidth = sum(enabledIds.map((id) => $columnsWidthState.start[id]));
              enabledIds.forEach((id) => {
                const startWidth = $columnsWidthState.start[id];
                if (startWidth !== void 0) {
                  $updatedState.current[id] = Math.max(0, startWidth + deltaWidth * (startWidth / totalStartWidth));
                }
              });
            } else {
              const startWidth = $columnsWidthState.start[cell.id];
              const { minWidth = 0, maxWidth } = columnOptions[cell.id] ?? {};
              if (startWidth !== void 0) {
                $updatedState.current[cell.id] = Math.min(Math.max(minWidth, startWidth + deltaWidth), ...maxWidth === void 0 ? [] : [maxWidth]);
              }
            }
            return $updatedState;
          });
        };
        const dragEnd = (event) => {
          event.stopPropagation();
          event.preventDefault();
          if (cell.isGroup()) {
            cell.ids.forEach((id) => {
              const node = nodeForId[id];
              if (node !== void 0) {
                columnWidths.update(($columnWidths) => ({
                  ...$columnWidths,
                  [id]: node.getBoundingClientRect().width
                }));
              }
            });
          } else {
            const node = nodeForId[cell.id];
            if (node !== void 0) {
              columnWidths.update(($columnWidths) => ({
                ...$columnWidths,
                [cell.id]: node.getBoundingClientRect().width
              }));
            }
          }
          onResizeEnd == null ? void 0 : onResizeEnd(event);
          if (event instanceof MouseEvent) {
            window.removeEventListener("mousemove", dragMove);
            window.removeEventListener("mouseup", dragEnd);
          } else {
            window.removeEventListener("touchmove", dragMove);
            window.removeEventListener("touchend", dragEnd);
          }
        };
        const $props = (node) => {
          nodeForId[cell.id] = node;
          if (cell.isFlat()) {
            columnWidths.update(($columnWidths) => ({
              ...$columnWidths,
              [cell.id]: node.getBoundingClientRect().width
            }));
          }
          return {
            destroy() {
              delete nodeForId[cell.id];
            }
          };
        };
        $props.drag = (node) => {
          node.addEventListener("mousedown", dragStart);
          node.addEventListener("touchstart", dragStart);
          return {
            destroy() {
              node.removeEventListener("mousedown", dragStart);
              node.removeEventListener("touchstart", dragStart);
            }
          };
        };
        $props.disabled = isCellDisabled(cell, disabledResizeIds);
        const props = derived([], () => {
          return $props;
        });
        const attrs = derived(columnWidths, ($columnWidths) => {
          const width = cell.isGroup() ? sum(cell.ids.map((id) => $columnWidths[id])) : $columnWidths[cell.id];
          if (width === void 0) {
            return {};
          }
          const widthPx = `${width}px`;
          return {
            style: {
              width: widthPx,
              "min-width": widthPx,
              "max-width": widthPx,
              "box-sizing": "border-box"
            }
          };
        });
        return { props, attrs };
      },
      "tbody.tr.td": (cell) => {
        const attrs = derived(columnWidths, ($columnWidths) => {
          const width = $columnWidths[cell.id];
          if (width === void 0) {
            return {};
          }
          const widthPx = `${width}px`;
          return {
            style: {
              width: widthPx,
              "min-width": widthPx,
              "max-width": widthPx,
              "box-sizing": "border-box"
            }
          };
        });
        return { attrs };
      }
    }
  };
};

// node_modules/svelte-headless-table/plugins/addSelectedRows.js
var isAllSubRowsSelectedForRow = (row, $selectedDataIds, linkDataSubRows) => {
  if (row.isData()) {
    if (!linkDataSubRows || row.subRows === void 0) {
      return $selectedDataIds[row.dataId] === true;
    }
  }
  if (row.subRows === void 0) {
    return false;
  }
  return row.subRows.every((subRow) => isAllSubRowsSelectedForRow(subRow, $selectedDataIds, linkDataSubRows));
};
var isSomeSubRowsSelectedForRow = (row, $selectedDataIds, linkDataSubRows) => {
  if (row.isData()) {
    if (!linkDataSubRows || row.subRows === void 0) {
      return $selectedDataIds[row.dataId] === true;
    }
  }
  if (row.subRows === void 0) {
    return false;
  }
  return row.subRows.some((subRow) => isSomeSubRowsSelectedForRow(subRow, $selectedDataIds, linkDataSubRows));
};
var writeSelectedDataIds = (row, value, $selectedDataIds, linkDataSubRows) => {
  if (row.isData()) {
    $selectedDataIds[row.dataId] = value;
    if (!linkDataSubRows) {
      return;
    }
  }
  if (row.subRows === void 0) {
    return;
  }
  row.subRows.forEach((subRow) => {
    writeSelectedDataIds(subRow, value, $selectedDataIds, linkDataSubRows);
  });
};
var getRowIsSelectedStore = (row, selectedDataIds, linkDataSubRows) => {
  const { subscribe } = derived(selectedDataIds, ($selectedDataIds) => {
    if (row.isData()) {
      if (!linkDataSubRows) {
        return $selectedDataIds[row.dataId] === true;
      }
      if ($selectedDataIds[row.dataId] === true) {
        return true;
      }
    }
    return isAllSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
  });
  const update = (fn) => {
    selectedDataIds.update(($selectedDataIds) => {
      const oldValue = isAllSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
      const $updatedSelectedDataIds = { ...$selectedDataIds };
      writeSelectedDataIds(row, fn(oldValue), $updatedSelectedDataIds, linkDataSubRows);
      if (row.parentRow !== void 0 && row.parentRow.isData()) {
        $updatedSelectedDataIds[row.parentRow.dataId] = isAllSubRowsSelectedForRow(row.parentRow, $updatedSelectedDataIds, linkDataSubRows);
      }
      return $updatedSelectedDataIds;
    });
  };
  const set = (value) => update(() => value);
  return {
    subscribe,
    update,
    set
  };
};
var addSelectedRows = ({ initialSelectedDataIds = {}, linkDataSubRows = true } = {}) => ({ tableState }) => {
  const selectedDataIds = recordSetStore(initialSelectedDataIds);
  const getRowState = (row) => {
    const isSelected = getRowIsSelectedStore(row, selectedDataIds, linkDataSubRows);
    const isSomeSubRowsSelected = derived([isSelected, selectedDataIds], ([$isSelected, $selectedDataIds]) => {
      if ($isSelected)
        return false;
      return isSomeSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
    });
    const isAllSubRowsSelected = derived(selectedDataIds, ($selectedDataIds) => {
      return isAllSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
    });
    return {
      isSelected,
      isSomeSubRowsSelected,
      isAllSubRowsSelected
    };
  };
  const _allRowsSelected = derived([tableState.rows, selectedDataIds], ([$rows, $selectedDataIds]) => {
    return $rows.every((row) => {
      if (!row.isData()) {
        return true;
      }
      return $selectedDataIds[row.dataId] === true;
    });
  });
  const setAllRowsSelected = ($allRowsSelected) => {
    if ($allRowsSelected) {
      const $rows = get_store_value(tableState.rows);
      const allDataIds = $rows.map((row) => row.isData() ? row.dataId : null).filter(nonNull);
      selectedDataIds.addAll(allDataIds);
    } else {
      selectedDataIds.clear();
    }
  };
  const allRowsSelected = {
    subscribe: _allRowsSelected.subscribe,
    update(fn) {
      const $allRowsSelected = get_store_value(_allRowsSelected);
      setAllRowsSelected(fn($allRowsSelected));
    },
    set: setAllRowsSelected
  };
  const someRowsSelected = derived([tableState.rows, selectedDataIds], ([$rows, $selectedDataIds]) => {
    return $rows.some((row) => {
      if (!row.isData()) {
        return false;
      }
      return $selectedDataIds[row.dataId] === true;
    });
  });
  const _allPageRowsSelected = derived([tableState.pageRows, selectedDataIds], ([$pageRows, $selectedDataIds]) => {
    return $pageRows.every((row) => {
      if (!row.isData()) {
        return true;
      }
      return $selectedDataIds[row.dataId] === true;
    });
  });
  const setAllPageRowsSelected = ($allPageRowsSelected) => {
    const $pageRows = get_store_value(tableState.pageRows);
    const pageDataIds = $pageRows.map((row) => row.isData() ? row.dataId : null).filter(nonNull);
    if ($allPageRowsSelected) {
      selectedDataIds.addAll(pageDataIds);
    } else {
      selectedDataIds.removeAll(pageDataIds);
    }
  };
  const allPageRowsSelected = {
    subscribe: _allPageRowsSelected.subscribe,
    update(fn) {
      const $allPageRowsSelected = get_store_value(_allPageRowsSelected);
      setAllPageRowsSelected(fn($allPageRowsSelected));
    },
    set: setAllPageRowsSelected
  };
  const somePageRowsSelected = derived([tableState.pageRows, selectedDataIds], ([$pageRows, $selectedDataIds]) => {
    return $pageRows.some((row) => {
      if (!row.isData()) {
        return false;
      }
      return $selectedDataIds[row.dataId] === true;
    });
  });
  const pluginState = {
    selectedDataIds,
    getRowState,
    allRowsSelected,
    someRowsSelected,
    allPageRowsSelected,
    somePageRowsSelected
  };
  return {
    pluginState,
    hooks: {
      "tbody.tr": (row) => {
        const props = derived(selectedDataIds, ($selectedDataIds) => {
          const someSubRowsSelected = isSomeSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
          const allSubRowsSelected = isAllSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
          const selected = row.isData() ? $selectedDataIds[row.dataId] === true : allSubRowsSelected;
          return {
            selected,
            someSubRowsSelected,
            allSubRowsSelected
          };
        });
        return { props };
      }
    }
  };
};

// node_modules/svelte-headless-table/utils/compare.js
var compare = (a, b) => {
  if (Array.isArray(a) && Array.isArray(b)) {
    return compareArray(a, b);
  }
  if (typeof a === "number" && typeof b === "number")
    return a - b;
  return a < b ? -1 : a > b ? 1 : 0;
};
var compareArray = (a, b) => {
  const minLength = Math.min(a.length, b.length);
  for (let i = 0; i < minLength; i++) {
    const order = compare(a[i], b[i]);
    if (order !== 0)
      return order;
  }
  return 0;
};

// node_modules/svelte-headless-table/plugins/addSortBy.js
var DEFAULT_TOGGLE_ORDER = ["asc", "desc", void 0];
var createSortKeysStore = (initKeys) => {
  const { subscribe, update, set } = writable(initKeys);
  const toggleId = (id, { multiSort = true, toggleOrder = DEFAULT_TOGGLE_ORDER } = {}) => {
    update(($sortKeys) => {
      const keyIdx = $sortKeys.findIndex((key2) => key2.id === id);
      const key = $sortKeys[keyIdx];
      const order = key == null ? void 0 : key.order;
      const orderIdx = toggleOrder.findIndex((o) => o === order);
      const nextOrderIdx = (orderIdx + 1) % toggleOrder.length;
      const nextOrder = toggleOrder[nextOrderIdx];
      if (!multiSort) {
        if (nextOrder === void 0) {
          return [];
        }
        return [{ id, order: nextOrder }];
      }
      if (keyIdx === -1 && nextOrder !== void 0) {
        return [...$sortKeys, { id, order: nextOrder }];
      }
      if (nextOrder === void 0) {
        return [...$sortKeys.slice(0, keyIdx), ...$sortKeys.slice(keyIdx + 1)];
      }
      return [
        ...$sortKeys.slice(0, keyIdx),
        { id, order: nextOrder },
        ...$sortKeys.slice(keyIdx + 1)
      ];
    });
  };
  const clearId = (id) => {
    update(($sortKeys) => {
      const keyIdx = $sortKeys.findIndex((key) => key.id === id);
      if (keyIdx === -1) {
        return $sortKeys;
      }
      return [...$sortKeys.slice(0, keyIdx), ...$sortKeys.slice(keyIdx + 1)];
    });
  };
  return {
    subscribe,
    update,
    set,
    toggleId,
    clearId
  };
};
var getSortedRows = (rows, sortKeys, columnOptions) => {
  const $sortedRows = [...rows];
  $sortedRows.sort((a, b) => {
    var _a, _b;
    for (const key of sortKeys) {
      const invert = ((_a = columnOptions[key.id]) == null ? void 0 : _a.invert) ?? false;
      const cellA = a.cellForId[key.id];
      const cellB = b.cellForId[key.id];
      let order = 0;
      const getSortValue = (_b = columnOptions[key.id]) == null ? void 0 : _b.getSortValue;
      if (!cellA.isData()) {
        return 0;
      }
      const valueA = cellA.value;
      const valueB = cellB.value;
      if (getSortValue !== void 0) {
        const sortValueA = getSortValue(valueA);
        const sortValueB = getSortValue(valueB);
        order = compare(sortValueA, sortValueB);
      } else if (typeof valueA === "string" || typeof valueA === "number") {
        order = compare(valueA, valueB);
      } else if (valueA instanceof Date && valueB instanceof Date) {
        order = compare(valueA.getTime(), valueB.getTime());
      }
      if (order !== 0) {
        let orderFactor = 1;
        if (key.order === "desc") {
          orderFactor *= -1;
        }
        if (invert) {
          orderFactor *= -1;
        }
        return order * orderFactor;
      }
    }
    return 0;
  });
  for (let i = 0; i < $sortedRows.length; i++) {
    const { subRows } = $sortedRows[i];
    if (subRows === void 0) {
      continue;
    }
    const sortedSubRows = getSortedRows(subRows, sortKeys, columnOptions);
    const clonedRow = $sortedRows[i].clone();
    clonedRow.subRows = sortedSubRows;
    $sortedRows[i] = clonedRow;
  }
  return $sortedRows;
};
var addSortBy = ({ initialSortKeys = [], disableMultiSort = false, isMultiSortEvent = isShiftClick, toggleOrder, serverSide = false } = {}) => ({ columnOptions }) => {
  const disabledSortIds = Object.entries(columnOptions).filter(([, option]) => option.disable === true).map(([columnId]) => columnId);
  const sortKeys = createSortKeysStore(initialSortKeys);
  const preSortedRows = writable([]);
  const deriveRows = (rows) => {
    return derived([rows, sortKeys], ([$rows, $sortKeys]) => {
      preSortedRows.set($rows);
      if (serverSide) {
        return $rows;
      }
      return getSortedRows($rows, $sortKeys, columnOptions);
    });
  };
  const pluginState = { sortKeys, preSortedRows };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "thead.tr.th": (cell) => {
        const disabled = disabledSortIds.includes(cell.id);
        const props = derived(sortKeys, ($sortKeys) => {
          const key = $sortKeys.find((k) => k.id === cell.id);
          const toggle = (event) => {
            if (!cell.isData())
              return;
            if (disabled)
              return;
            sortKeys.toggleId(cell.id, {
              multiSort: disableMultiSort ? false : isMultiSortEvent(event),
              toggleOrder
            });
          };
          const clear = () => {
            if (!cell.isData())
              return;
            if (disabledSortIds.includes(cell.id))
              return;
            sortKeys.clearId(cell.id);
          };
          return {
            order: key == null ? void 0 : key.order,
            toggle,
            clear,
            disabled
          };
        });
        return { props };
      },
      "tbody.tr.td": (cell) => {
        const props = derived(sortKeys, ($sortKeys) => {
          const key = $sortKeys.find((k) => k.id === cell.id);
          return {
            order: key == null ? void 0 : key.order
          };
        });
        return { props };
      }
    }
  };
};

// node_modules/svelte-headless-table/plugins/addSubRows.js
var withSubRows = (row, getChildren) => {
  const subItems = getChildren(row.original);
  if (subItems === void 0) {
    return row;
  }
  const subRows = getSubRows(subItems, row);
  row.subRows = subRows.map((row2) => withSubRows(row2, getChildren));
  return row;
};
var addSubRows = ({ children }) => () => {
  const getChildren = children instanceof Function ? children : (item) => item[children];
  const deriveRows = (rows) => {
    return derived(rows, ($rows) => {
      return $rows.map((row) => {
        if (row.isData()) {
          return withSubRows(row, getChildren);
        }
        return row;
      });
    });
  };
  return {
    pluginState: {},
    deriveRows
  };
};

// node_modules/svelte-headless-table/plugins/addTableFilter.js
var getFilteredRows2 = (rows, filterValue, columnOptions, { tableCellMatches, fn, includeHiddenColumns }) => {
  const $filteredRows = rows.map((row) => {
    const { subRows } = row;
    if (subRows === void 0) {
      return row;
    }
    const filteredSubRows = getFilteredRows2(subRows, filterValue, columnOptions, {
      tableCellMatches,
      fn,
      includeHiddenColumns
    });
    const clonedRow = row.clone();
    clonedRow.subRows = filteredSubRows;
    return clonedRow;
  }).filter((row) => {
    var _a;
    if ((((_a = row.subRows) == null ? void 0 : _a.length) ?? 0) !== 0) {
      return true;
    }
    const rowCellMatches = Object.values(row.cellForId).map((cell) => {
      const options = columnOptions[cell.id];
      if ((options == null ? void 0 : options.exclude) === true) {
        return false;
      }
      const isHidden = row.cells.find((c) => c.id === cell.id) === void 0;
      if (isHidden && !includeHiddenColumns) {
        return false;
      }
      if (!cell.isData()) {
        return false;
      }
      let value = cell.value;
      if ((options == null ? void 0 : options.getFilterValue) !== void 0) {
        value = options == null ? void 0 : options.getFilterValue(value);
      }
      const matches = fn({ value: String(value), filterValue });
      if (matches) {
        const dataRowColId = cell.dataRowColId();
        if (dataRowColId !== void 0) {
          tableCellMatches[dataRowColId] = matches;
        }
      }
      return matches;
    });
    return rowCellMatches.includes(true);
  });
  return $filteredRows;
};
var addTableFilter = ({ fn = textPrefixFilter2, initialFilterValue = "", includeHiddenColumns = false, serverSide = false } = {}) => ({ columnOptions }) => {
  const filterValue = writable(initialFilterValue);
  const preFilteredRows = writable([]);
  const tableCellMatches = recordSetStore();
  const pluginState = { filterValue, preFilteredRows };
  const deriveRows = (rows) => {
    return derived([rows, filterValue], ([$rows, $filterValue]) => {
      preFilteredRows.set($rows);
      tableCellMatches.clear();
      const $tableCellMatches = {};
      const $filteredRows = getFilteredRows2($rows, $filterValue, columnOptions, {
        tableCellMatches: $tableCellMatches,
        fn,
        includeHiddenColumns
      });
      tableCellMatches.set($tableCellMatches);
      if (serverSide) {
        return $rows;
      }
      return $filteredRows;
    });
  };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "tbody.tr.td": (cell) => {
        const props = derived([filterValue, tableCellMatches], ([$filterValue, $tableCellMatches]) => {
          const dataRowColId = cell.dataRowColId();
          return {
            matches: $filterValue !== "" && dataRowColId !== void 0 && ($tableCellMatches[dataRowColId] ?? false)
          };
        });
        return { props };
      }
    }
  };
};
var textPrefixFilter2 = ({ filterValue, value }) => {
  if (filterValue === "") {
    return true;
  }
  return String(value).toLowerCase().startsWith(String(filterValue).toLowerCase());
};
export {
  addColumnFilters,
  addColumnOrder,
  addDataExport,
  addExpandedRows,
  addFlatten,
  addGridLayout,
  addGroupBy,
  addHiddenColumns,
  addPagination,
  addResizedColumns,
  addSelectedRows,
  addSortBy,
  addSubRows,
  addTableFilter,
  matchFilter,
  numberRangeFilter,
  textPrefixFilter
};
/*! Bundled license information:

svelte-keyed/dist/index.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=svelte-headless-table_plugins.js.map
